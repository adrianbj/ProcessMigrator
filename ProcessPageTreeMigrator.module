<?php

/**
 * ProcessWire Page Tree Migrator
 * by Adrian Jones
 *
 * Allows automated migration and sharing of page trees along with their templates and fields.
 *
 * ProcessWire 2.x
 * Copyright (C) 2011 by Ryan Cramer
 * Licensed under GNU/GPL v2, see LICENSE.TXT
 *
 * http://www.processwire.com
 * http://www.ryancramer.com
 *
 */

class ProcessPageTreeMigrator extends Process implements Module {

    /**
     * getModuleInfo is a module required by all modules to tell ProcessWire about them
     *
     * @return array
     *
     */
    public static function getModuleInfo() {
        return array(
            'title' => 'Page Tree Migrator',
            'version' => 37,
            'summary' => 'Automated migrate page trees (including their templates and fields) from one PW installation to another',
            'singular' => true,
            'autoload' => false,
            );
    }

    /**
     * Name used for the page created in the admin
     *
     */
    const adminPageName = 'page-tree-migrator';


    protected $pageFiles = array();
    protected $repeaterSubFields = array();
    protected $templateFiles = array();
    protected $migratedTemplateFileNames = array();


    /**
     * Filenames with folder/paths to data files
     *
     */
    protected $zipFilename = '';
    protected $jsonFilename = '';
    protected $migratorFilesDir = '';

    /**
     * Instance of Template, used for imported pages
     *
     */
    protected $template = null;

    /**
     * Instance of Page, representing the parent Page for imported pages
     *
     */
    protected $parent = null;

    /**
     * Initialize the module
     *
     */
    public function init() {
        parent::init();
        ini_set('auto_detect_line_endings', true);
    }

    /**
     * Executed when root url for module is accessed
     *
     */
    public function ___execute() {

        $form = $this->buildForm1();
        if($this->input->post->submit) {
            if($this->processForm1($form) || $this->processExportForm2($form) || $this->processImportForm2($form)) $this->session->redirect('./'.$this->input->post->type.'/');
        }
        return $form->render();
    }

    /**
     * Executed when ./export/ url for module is accessed
     *
     */
    public function ___executeExport() {

        $form = $this->buildExportForm2();
        if($this->input->post->submit) {
            return $this->processExportForm2($form);
        } else {
            $form = $this->buildExportForm2();
            return $form->render();
        }
    }


    /**
     * Executed when ./import/ url for module is accessed
     *
     */
    public function ___executeImport() {

        $form = $this->buildImportForm2();
        if($this->input->post->submit) {
            return $this->processImportForm2($form);
        } else {
            $form = $this->buildImportForm2();
            return $form->render();
        }

    }




/**
     * Build the "Step 1" form
     *
     */
    protected function buildForm1() {

        $form = $this->modules->get("InputfieldForm");
        $form->method = 'post';
        $form->description = "Step 1: Export or Import";

        $f = $this->modules->get("InputfieldSelect");
        $f->name = 'type';
        $f->label = 'Export or Import';
        $f->required = true;
        $f->addOption('');
        $f->addOption('export', 'Export');
        $f->addOption('import', 'Import');
        if($this->session->type) $f->attr('value', $this->session->type);
        $form->add($f);

        $this->addSubmit($form, 'Continue to Step 2');

        return $form;
    }



    /**
     * Process the "Step 1" form and populate session variables with the results
     *
     */
    protected function processForm1(InputfieldForm $form) {

        $form->processInput($this->input->post);
        if(count($form->getErrors())) return false;

        $this->session->type = (int) $form->get('type')->value;

        $type = $form->get('type')->value;

        if(!$type) {
            $this->error("Missing required Export/Import action type");
            return false;
        }

        $this->session->type = $type;
        return true;
    }




    /**
     * Build the "Export Step 2" form
     *
     */
    protected function buildExportForm2() {

        $form = $this->modules->get("InputfieldForm");
        $form->method = 'post';
        $form->description = "Step 2: Export Page Tree";

        $f = $this->modules->get("InputfieldPageListSelect");
        $f->name = 'treeParent';
        $f->label = 'Parent Page';
        $f->required = true;
        $f->description = "The parent of the page tree you want to export.";
        if($this->session->treeParent) $f->attr('value', $this->session->treeParent);
        $form->add($f);

        $f = $this->modules->get("InputfieldSelect");
        $f->name = 'export_components';
        $f->label = 'Components to export';
        $f->required = true;
        $f->addOption('');
        $f->addOption('everything', 'Everything, including all data pages');
        $f->addOption('fields_templates_and_structural_pages', 'Fields, Templates and Structural Pages');
        $f->addOption('fields_and_templates_only', 'Fields and Templates Only');
        if($this->session->export_components) $f->attr('value', $this->session->export_components);
        $form->add($f);

        $f = $this->modules->get("InputfieldSelect");
        $f->name = 'save_or_copy';
        $f->label = 'Output Format';
        $f->description = "SAVE zip file to your computer OR display code so you can COPY and then paste into new site.\nNB Copy will not work for migrating full page content if there are included files/images. It also won't migrate required template files.";
        $f->required = true;
        $f->addOption('');
        $f->addOption('save', 'Save');
        $f->addOption('copy', 'Copy');
        if($this->session->save_or_copy) $f->attr('value', $this->session->save_or_copy);
        $form->add($f);

        $this->addSubmit($form, 'Export');

        return $form;
    }

    /**
     * Process the "Step 2" form and populate session variables with the results
     *
     */
    protected function processExportForm2(InputfieldForm $form) {

        $form->processInput($this->input->post);
        if(count($form->getErrors())) return false;

        $this->session->treeParent = (int) $this->input->treeParent;
        $this->session->save_or_copy = $this->input->save_or_copy;
        $this->session->export_components = $this->input->export_components;

        //find all the relevant pages under the selected parent and then sort them by child level (count path segments) to make sure parents are added to the JSON before their children
        $items = $this->pages->get($this->session->treeParent)->find("id!=2, id!=7, has_parent!=2, has_parent!=7, template!=admin, sort=id, include=all"); // exclude admin and trash in case the user chooses the 'Home' as the parent
        // create empty page array
        $res = new PageArray();
        foreach($items as $item) {
            // temporarely add pathsegments property to items
            $item->pathsegments = count(explode('/',$item->path));
            $res->add($item);
        }
        $items = $res->filter("sort=pathsegments");


        $parent_item = $this->pages->get($this->session->treeParent);
        $items->prepend($parent_item);

        if($this->session->save_or_copy == 'copy'){
            return '<p><textarea rows="10" style="width:95%">' . $this->pagesToJSON($items, $this->session->export_components) . '</textarea></p><p>Copy this text and import it into your new site using the paste option.</p><p><a href="../export/">Export more pages</a></p>';
        }
        else{
            $this->jsonFilename = $this->page->filesManager()->path() . 'data.json';
            //header('Content-disposition: attachment; filename='.$this->pages->get($this->session->treeParent)->name.'.json');
            //header('Content-type: application/json');
            //echo ($this->pagesToJSON($items, $this->session->export_components));
            //exit;

            //write json file to assets folder and add it to the zip download
            file_put_contents($this->jsonFilename, $this->pagesToJSON($items, $this->session->export_components));
            $allfiles = array($this->jsonFilename);
            $this->create_zip($allfiles, $this->page->filesManager()->path().'files.zip', 'json');
            unlink($this->jsonFilename);

            //download the zip to the users
            $this->zipFilename = $this->page->filesManager()->path().'files.zip';
            if (file_exists($this->zipFilename)) {
                header('Content-Description: File Transfer');
                header('Content-Type: application/zip');
                header('Content-Disposition: attachment; filename='.basename($this->zipFilename));
                header('Expires: 0');
                header('Cache-Control: must-revalidate');
                header('Pragma: public');
                header('Content-Length: ' . filesize($this->zipFilename));
                ob_clean();
                flush();
                readfile($this->zipFilename);
                unlink($this->zipFilename);
                exit;
            }
        }

    }

    /**
     * Build the "Import Step 2" form to import the json file
     *
     */
    protected function buildImportForm2() {


        $form = $this->modules->get("InputfieldForm");
        $form->method = 'post';
        $form->description = "Step 2: Import Page Tree";

        $f = $this->modules->get("InputfieldPageListSelect");
        $f->name = 'import_to_parent';
        $f->label = 'Parent Page';
        $f->description = "The parent that you want the imported pages added to.\r\nNB This is not required if you choose 'Fields and Templates Only' from the options below.";
        if($this->session->import_to_parent) $f->attr('value', $this->session->import_to_parent);
        $form->add($f);

        $f = $this->modules->get("InputfieldSelect");
        $f->name = 'import_components';
        $f->label = 'Components to import';
        $f->required = true;
        $f->addOption('everything', 'Everything, including all data pages');
        //$f->addOption('fields_templates_and_structural_pages', 'Fields, Templates and Structural Pages');
        $f->addOption('fields_and_templates_only', 'Fields and Templates Only');
        if($this->session->import_components) $f->attr('value', $this->session->import_components);
        $form->add($f);

        $fieldset = $this->modules->get("InputfieldFieldset");
        $fieldset->attr('id', 'json_source_options');
        $fieldset->label = "Data Source";
        $fieldset->description = "Choose one of the following options as the source of the data.\r\nIf you are importing \"Everything, including all data pages\" and you have files/images in the pages, then you must choose the zip upload.\r\nNB: The structure of this JSON is critical, so it is important that it was created using the export feature of this module.";
        $form->add($fieldset);

        $f = $this->modules->get("InputfieldFile");
        $f->name = 'zip_file';
        $f->label = 'Zip File Upload';
        $f->extensions = 'zip';
        $f->maxFiles = 1;
        $f->descriptionRows = 0;
        $f->overwrite = true;
        $f->collapsed = Inputfield::collapsedBlank;
        $fieldset->add($f);

        $f = $this->modules->get("InputfieldTextarea");
        $f->name = 'json_data';
        $f->label = 'Paste in JSON Data';
        $f->collapsed = Inputfield::collapsedBlank;
        $fieldset->add($f);

        $f = $this->modules->get("InputfieldSelect");
        $f->name = 'json_package';
        $f->label = 'Shared JSON packages';
        //$packages = json_decode(file_get_contents('https://raw.github.com/adrianbj/ProcessWirePageLists/master/packages.json'));
        $options  = array('http' => array('user_agent' => 'adrianbj'));
        $context  = stream_context_create($options);
        $packages = json_decode(file_get_contents('https://api.github.com/repos/adrianbj/ProcessWirePageLists/contents/', false, $context));
        if(!is_array($packages)) {
            $this->error("Github rate limit has been exceeded. Please try again shortly.");
            $f->description = __("Github rate limit has been exceeded. Please try again shortly.");
        }
        else{
            $f->addOption('');
            foreach($packages as $package){
                $package_name = pathinfo($package->html_url, PATHINFO_FILENAME);
                $package_raw_url = str_replace('//','//raw.', str_replace('blob/','',$package->html_url));
                if($package_name != 'README') $f->addOption($package_raw_url, $package_name);
            }
            if($this->session->json_package) $f->attr('value', $this->session->json_package);
            $f->description = __("Select from one of the shared JSON packages.\r\nMore details about these packages are available at the ProcessWirePageLists Github page: [https://github.com/adrianbj/ProcessWirePageLists](https://github.com/adrianbj/ProcessWirePageLists)");
        }
        $f->collapsed = Inputfield::collapsedBlank;
        $fieldset->add($f);

        $f = $this->modules->get("InputfieldURL");
        $f->name = 'json_url';
        $f->label = 'URL to JSON file';
        $f->description = "Enter a URL directly to a .json file, eg: [https://raw.github.com/adrianbj/ProcessWirePageLists/master/countries.json](https://raw.github.com/adrianbj/ProcessWirePageLists/master/countries.json)";
        $f->collapsed = Inputfield::collapsedBlank;
        $fieldset->add($f);


        $this->addSubmit($form, 'Upload and Create Content');

        return $form;
    }

    /**
     * Process the "Import Step 2" form and upload the json file
     *
     */
    protected function processImportForm2(InputfieldForm $form) {

        $form->processInput($this->input->post);
        if(count($form->getErrors())) return false;

        $this->session->import_to_parent = (int) $this->input->import_to_parent;
        $this->session->import_components = $this->input->import_components;


        if(!$this->session->import_to_parent && $this->session->import_components != 'fields_and_templates_only') {
            $this->error("Missing required parent page. This must be selected if you want to import the pages in addition to field and template creation.");
            $this->session->redirect('./'.$this->input->post->type);
        }


        $zipFile = $form->get('zip_file')->value;
        $jsonData = $form->get('json_data')->value;
        $jsonPackage = $form->get('json_package')->value;
        $jsonURL = $form->get('json_url')->value;


        if(count($zipFile)) {
            $zipFile = $zipFile->first();
            $zipFile->rename("data.zip");
            $this->zipFilename = $zipFile->filename;

            // extract uploaded zip to destination PW installation
            $zip = new ZipArchive;
            if($zip->open($this->zipFilename) === TRUE) {
                $this->migratorFilesDir = $this->page->filesManager()->path() . 'migratorfiles';
                $zip->extractTo($this->migratorFilesDir);
                $zip->close();
                unlink($this->zipFilename);

                // move all template files into the destination PW site's templates folder
                $srcDir = $this->migratorFilesDir . '/templates/';
                $destDir = $this->config->paths->templates.'/';

                if (file_exists($srcDir) && is_dir($srcDir) && $handle = opendir($srcDir)) {
                    /*while (false !== ($file = readdir($handle))) {
                      if (is_file($srcDir . '/' . $file)) {
                        $this->migratedTemplateFileNames[] = $file;
                        rename($srcDir . $file, $destDir . $file);
                      }
                    }
                    closedir($handle);*/
                    foreach($iterator = new RecursiveIteratorIterator(new RecursiveDirectoryIterator($srcDir, RecursiveDirectoryIterator::SKIP_DOTS), RecursiveIteratorIterator::SELF_FIRST) as $item){
                        $this->migratedTemplateFileNames[] = str_replace($this->migratorFilesDir, '', $item);
                        if ($item->isDir()) {
                            mkdir($destDir . DIRECTORY_SEPARATOR . $iterator->getSubPathName());
                        }
                        else {
                            copy($item, $destDir . DIRECTORY_SEPARATOR . $iterator->getSubPathName());
                        }
                    }
                }

                //populate $fp with contents of json file, exatracted from uploaded zip
                $fp = file_get_contents($this->migratorFilesDir . '/data.json');
            }

        }
        else{

            if(strlen($jsonData)) {
                $json = $jsonData;
            }
            else if(strlen($jsonPackage)) {
                $json = file_get_contents($jsonPackage);
            }
            else if(strlen($jsonURL)) {
                $json = file_get_contents($jsonURL);
            }

            $this->jsonFilename = $this->page->filesManager()->path() . 'data.json';
            file_put_contents($this->jsonFilename, $json);

            //populate $fp with data from json file written to the server from pasted, or externally linked JSON file
            $fp = file_get_contents($this->jsonFilename);
            unlink($this->jsonFilename);

        }

        //if no data source provided, return an error
        if(empty($fp)){
            $this->error("Missing required ZIP or JSON Source");
            $this->session->redirect('./'.$this->input->post->type);
        }


        //populate $data with json string of all the content to be created
        $data = json_decode($fp);


        //Templates - first iteration to create templates
        foreach($data->templates as $np){

            if(!$this->fieldgroups->{$np->template}) {
                $fg = new Fieldgroup();
                $fg->name = $np->template;
                $fg->add("title");
                $fg->save();
            }
            else{
                $fg = $this->fieldgroups->{$np->template};
            }

            if(!$this->templates->{$np->template}) {
                $template = new Template();
                $template->name = $np->template;
                $template->fieldgroup = $fg;
                $template->save();
            }
            else{
                $template = $this->templates->{$np->template};
            }

        }


        //Templates - second iteration to save settings.
        // had to separate because it isn't possible to populate childTemplates / parentTemplates arrays if the template to be set isn't created yet
        foreach($data->templates as $np){

            $template = $this->templates->{$np->template};
            $fg = $this->fieldgroups->{$np->template};

            if(isset($np->data)) {
                foreach($np->data as $np_field_name => $np_field_value){
                    //Roles (Access Tab)
                    if(stripos($np_field_name,'Roles') !== false && is_array($np_field_value)) {
                        $id = array_map(array($this, 'getRoleIDFromName'), $np_field_value);
                        if($id) $template->$np_field_name = $id;
                    }
                    //Child and Parent template settings (Family Tab)
                    elseif(is_array($np_field_value)) {
                        $id = array_map(array($this, 'getTemplateIDFromName'), $np_field_value);
                        $template->$np_field_name = $id;
                    }
                    else{
                        $template->$np_field_name = $np_field_value;
                    }
                }
            }

            $template->fieldgroup = $fg;
            $template->save();

        }



        //Fields
        $pagefield_parent_ids = array();
        foreach($data->fields as $np){

            $template = $this->templates->{$np->template};

            if(!$this->fields->get($np->name)){
                $field = new Field();
                $field->type = $this->modules->get($np->type); // get a field type
                $field->name = $np->name;
                $field->label = $np->label;
                $field->description = $np->description;
                $field->flags = $np->flags;

                if(isset($np->data)) {
                    foreach($np->data as $np_field_name => $np_field_value){

                        if($this->modules->get($np->type) == "FieldtypeRepeater"){

                            $this->modules->get("FieldtypeRepeater"); // install repeater module if it's not already installed.

                            $repeater_fieldgroup = "repeater_{$np->name}";

                            if(!$this->fieldgroups->$repeater_fieldgroup) {
                                $repeater_fg = new Fieldgroup();
                                $repeater_fg->name = $repeater_fieldgroup;
                            }
                            else{
                                $repeater_fg = $this->fieldgroups->$repeater_fieldgroup;
                            }

                            if(is_array($np_field_value)) {
                                foreach($np_field_value as $rf){
                                    $repeater_fg->append($rf); // populates fieldgroups_fields with IDs of repeater subfields
                                }
                            }
                            $repeater_fg->save();

                            if(!$this->templates->$repeater_fieldgroup) {
                                $repeater_template = new Template();
                                $repeater_template->name = $repeater_fieldgroup;
                                $repeater_template->flags = 8;
                                $repeater_template->noChildren = 1;
                                $repeater_template->noParents = 1;
                                $repeater_template->noGlobal = 1;
                                $repeater_template->slashUrls = 1;
                                $repeater_template->fieldgroup = $repeater_fg;
                                $repeater_template->save();
                            }
                            else{
                                $repeater_template = $this->templates->$repeater_fieldgroup;
                            }

                            // need to override these values in the JSON data because they come from the source PW install and aren't relevant here when importing
                            if($np_field_name == "template_id") $np_field_value = $repeater_template->id;
                            if($np_field_name == "parent_id") {
                                $repeater_page = "for-field-{$field->id}";
                                $np_field_value = $this->pages->get("name=$repeater_page")->id;
                            }
                        }

                        if($this->modules->get($np->type) == "FieldtypePage"){
                            // need to override these values in the JSON data because they come from the source PW install and aren't relevant here when importing
                            if($np_field_name == "template_id") $np_field_value = $this->templates->get("name=$np_field_value")->id;
                            // populate array with parent_id names for page fields so that they can be added once the parent page has been created below in the pages section
                            if($np_field_name == "parent_id") $pagefield_parent_ids[$np->name] = $np_field_value;
                        }

                        if(is_array($np_field_value)) { // think this is limited to repeaters and nothing else - need to check
                            $id = array_map(array($this, 'getFieldIDFromName'), $np_field_value);
                            $field->$np_field_name = $id; // populates fields > data > repeaterFields with IDs of repeater subfields
                        }
                        else{
                            $field->$np_field_name = $np_field_value;
                        }

                    }
                }

                $field->save(); // save the field
                if($template) $template->fieldgroup->append($field); // add new field to template. If $template checks are for repeater subfields - don't want to add these to a standard template
            }
            else{
                if($template) $template->fieldgroup->append($this->fields->{$np->name}); // add existing field to template - NB: this does not change any of the attributes of a field if it already exists - this could be problematic for the import
            }

            if($template) $template->fieldgroup->save();

        }


        //Pages
        $i=0;
        $top_parent_page = '';

        if($this->session->import_components == 'everything'){

            if(isset($data->pages)){

                foreach($data->pages as $np){

                    $import_to_parent = $this->pages->get($form->get('import_to_parent')->value);
                    $parent = $this->pages->get($import_to_parent->path.$np->parent_name);
                    if(!$parent->id) $parent = $this->pages->get('/');

                    //if($i==1) $top_parent_page = $parent; // old way for getting link to show created page tree - new way is about 10 lines below here

                    if(!$this->pages->get("name={$np->name}, template={$np->page_template}, parent=$parent")->id){ //Check to see if a page with same name, template and parent already exists before creating it
                        $page = new Page();
                        $page->parent = $parent;
                        $page->template = $this->templates->{$np->page_template};
                        $page->name = $np->name;
                        $page->status = $np->status;
                        $page->sort = $np->sort;
                        if(isset($np->sortfield)) $page->sortfield = $np->sortfield;
                        $page->of(false);
                        $page->save();

                        if($i==0) $top_parent_page = $page; //Used for link to show created page tree

                        if(isset($np->data)) {
                            foreach($np->data as $np_field_name => $np_field_value){

                                if(is_object($np_field_value) && array_key_exists('default', $np_field_value)){ // this is for multi language versions of fields - the check for 'default' key should distinguish it from other fields that are objects
                                    $this->modules->get("LanguageSupport"); // install language support module if it's not already installed. Might also need to install other language modules too?
                                    foreach($np_field_value as $language => $field_value){
                                        $page->$np_field_name->setLanguageValue($this->languages->get($language), $this->abstractedLinkEncoder($field_value));
                                    }
                                }
                                elseif($page->fields->get($np_field_name) && $page->fields->get($np_field_name)->type instanceof FieldtypeFile){ // this is for file/image fields
                                    foreach($np_field_value as $file) {

                                        $tmpImgDir = $this->page->filesManager()->path().'migratorfiles/pages/'.$this->removeParentFromPath($page->path, $this->session->import_to_parent, 'import');
                                        $tempImgDir = str_replace('//', '/', $tmpImgDir);
                                        $filepath = $tmpImgDir.$file->data;

                                        if(file_exists($filepath)){
                                            $page->$np_field_name->add($filepath);

                                            //This was here for trying to support rename of save on in Custom Upload Names when images embedded into RTE fields.
                                            //Will revisit later
                                            /*if($page->fields->get($np_field_name) && $page->fields->get($np_field_name)->type instanceof FieldtypeImage){

                                                $dir = new DirectoryIterator($tmpImgDir);
                                                foreach($dir as $tmpfile) {
                                                    if($tmpfile->isDir() || $tmpfile->isDot()) continue;
                                                    if($this->isImgVarOf(pathinfo($filepath, PATHINFO_BASENAME), pathinfo($tmpImgDir.$tmpfile, PATHINFO_BASENAME))){
                                                        rename($tmpImgDir.$tmpfile, $page->filesManager()->path() . $tmpfile);
                                                    }
                                                }
                                            }*/

                                            unlink($filepath); //remove from migratorfiles temp folder so that it won't get re-copied with the variations a little further down

                                            $page->of(false);
                                            $page->save($np_field_name);
                                            $page->$np_field_name->last()->description = $file->description;
                                            if($this->fields->$np_field_name->useTags == 1) $page->$np_field_name->last()->tags = $file->tags;
                                            $page->save($np_field_name);
                                        }

                                        //no longer needed as all additional versions of images are now copied across anyway
                                        //copy all versions of FieldtypeCropImage images from the Thumbnails module into the final assets/files/id folder
                                        /*$field = $page->fields->get($np_field_name);
                                        if($field->thumbSetting){
                                            $crops = $field->thumbSetting;
                                            $crops_a = explode("\n", $crops);
                                            foreach($crops_a as $crop) {
                                                $crop = explode(',', $crop);
                                                $name = wire('sanitizer')->name($crop[0]);
                                                if(!strlen($name)) continue;
                                                $cropFilename = $this->page->filesManager()->path().'migratorfiles/pages/'.$this->removeParentFromPath($page->path, $this->session->import_to_parent, 'import') . $name . '_' . $file->data;
                                                $cropFilename = str_replace('//', '/', $cropFilename);
                                                if(is_file($cropFilename)) {
                                                    copy($cropFilename, $page->filesManager()->path() . pathinfo($cropFilename, PATHINFO_BASENAME));
                                                }
                                            }
                                        }*/
                                    }
                                }
                                //elseif(is_array($np_field_value)){ // this is for page field selected values, but maybe there are other things that might be arrays that need to be dealt with?
                                elseif($page->fields->get($np_field_name) && $page->fields->get($np_field_name)->type == 'FieldtypePage'){ // this is for page fields
                                    // these were breaking page fields and not needed because all of this is taken care of in the next loop further down
                                    // need to grab the first (and only item) from the return array if the page field is a single type
                                    /*if($page->$np_field_name instanceof Page) {
                                        $page->$np_field_name = $this->getPageFieldIDFromName($np_field_value)[0];
                                    // else add the entire array to multi page field
                                    } else if($page->$np_field_name instanceof PageArray) {
                                        $page->$np_field_name = $this->getPageFieldIDFromName($np_field_value);
                                    }*/
                                }
                                elseif($page->fields->get($np_field_name) && $page->fields->get($np_field_name)->type == 'FieldtypeRepeater'){ // this is for repeater fields
                                    $n=0;
                                    foreach($np_field_value as $subfield => $valuearray){
                                        $newrf = $page->$np_field_name->getNew(); // getNew() is special PW helper method for creating new repeater items (http://processwire.com/api/fieldtypes/repeaters/)
                                        $newrf->save();
                                        $this->repeaterSubFields[] = $newrf;
                                        $page->save(); //needed for repeaters with file/image fields
                                        $page->of(false);
                                        foreach($valuearray as $field => $value){
                                            if($page->fields->get($field) && $page->fields->get($field)->type instanceof FieldtypeFile){ // this is for file/image fields
                                                foreach($value as $file) {
                                                    $filepath = $this->page->filesManager()->path().'migratorfiles/pages/'.$this->removeParentFromPath($page->path, $this->session->import_to_parent, 'import').$np_field_name.'_'.$n.'/'.$file->basename;
                                                    $filepath = str_replace('//', '/', $filepath);
                                                    $newrf->$field->add($filepath);
                                                    unlink($filepath); //remove from migratorfiles temp folder so that it won't get re-copied with the variations a little further down
                                                    $newrf->of(false);
                                                    $newrf->save($field);
                                                    $newrf->$field->last()->description = $file->description;
                                                    if($this->fields->$field->useTags == 1) $newrf->$field->last()->tags = $file->tags;
                                                    $newrf->save($field);
                                                }
                                            }
                                            else{
                                                $newrf->$field = $value;
                                                $newrf->save();
                                            }
                                        }
                                        $page->save();
                                        $n++;
                                    }
                                }
                                else{
                                    $page->$np_field_name = $this->abstractedLinkEncoder($this->idImagePath($np_field_value, $page));
                                }
                            }
                        }

                        $page->save();

                        // move all the remaining (should be just the variations) page files into the destination PW site's assets/files/id folder
                        //normal file/image fields
                        $srcDir = $this->migratorFilesDir . '/pages/' . $this->removeParentFromPath($page->path, $this->session->import_to_parent, 'import');
                        $srcDir = str_replace('//', '/', $srcDir);
                        $destDir = $page->filesManager()->path();

                        if (file_exists($srcDir) && is_dir($srcDir) && $handle = opendir($srcDir)) {
                            while (false !== ($file = readdir($handle))) {
                              if (is_file($srcDir . $file)) {
                                rename($srcDir . $file, $destDir . $file);
                              }
                            }
                            closedir($handle);
                        }

                        // repeater file/image fields
                        $n=0;
                        foreach($this->repeaterSubFields as $rsf){
                            $srcDir = $this->migratorFilesDir . '/pages/' . $this->removeParentFromPath($page->path, $this->session->import_to_parent, 'import').$np_field_name.'_'.$n.'/';
                            $srcDir = str_replace('//', '/', $srcDir);
                            $destDir = $rsf->filesManager()->path();

                            if (file_exists($srcDir) && is_dir($srcDir) && $handle = opendir($srcDir)) {
                                while (false !== ($file = readdir($handle))) {
                                  if (is_file($srcDir . $file)) {
                                    rename($srcDir . $file, $destDir . $file);
                                  }
                                }
                                closedir($handle);
                            }
                            $n++;
                        }

                    }

                    $i++;

                }

            }

        }

        //add parent_id to page fields now that the parent page has been created
        foreach($pagefield_parent_ids as $pagefield_name => $pagefield_parent_id_name){
            $pagefield = $this->fields->get($pagefield_name);
            $pagefield->parent_id = $this->pages->get("name=$pagefield_parent_id_name")->id;
            $pagefield->save();
        }

        // run through pages again to populate page field data now that the page fields selectable pages have been created
        if($this->session->import_components == 'everything'){

            if(isset($data->pages)){
                foreach($data->pages as $np){

                    $import_to_parent = $this->pages->get($form->get('import_to_parent')->value);
                    $parent = $this->pages->get($import_to_parent->path.$np->parent_name.'/');
                    if(!$parent->id) $parent = $this->pages->get('/');

                    $cp = $this->pages->get("name={$np->name}, template={$np->page_template}, parent=$parent");
                    if(!$cp->id) continue;
                    if(isset($np->data)) {
                        foreach($np->data as $np_field_name => $np_field_value){

                            if($cp->fields->get($np_field_name) && $cp->fields->get($np_field_name)->type == 'FieldtypePage'){ // this is for page fields
                                $cp->of(false);

                                $fieldid = $this->getPageFieldIDFromName($np_field_value, $np_field_name);
                                // need to grab the first [0] (and only item) from the return array if the page field is a single type
                                if($cp->$np_field_name instanceof Page) {
                                    if(is_array($np_field_value) && !empty($np_field_value)) $cp->$np_field_name = $fieldid[0];
                                // else add the entire array to multi page field
                                } else if($cp->$np_field_name instanceof PageArray) {
                                    $cp->$np_field_name = $fieldid;
                                }

                                $cp->save();
                            }
                        }
                    }
                    $cp->of(false);
                    $cp->save();
                }
            }
        }

        //remove the extracted folder of all the migrated files, templates, and json file
        if(isset($this->migratorFilesDir) && file_exists($this->migratorFilesDir)) $this->recursiveDelete($this->migratorFilesDir);

        return $this->processImportForm2Markup($i, $top_parent_page != '' ? $top_parent_page->id : false);

    }


    /**
     * Push all relevant templates, fields and pages to the pageToArray function and then JSON encode
     *
     */
    protected function pagesToJSON(PageArray $items, $export_components) {

        $a = array();
        $pages_array = array();
        $templates_array = array();
        $fields_array = array();
        $current_template = array();
        $i=0;
        foreach($items as $item) {

            //Pages
            if($export_components != 'fields_and_templates_only'){
                if($export_components == 'everything' || ($export_components == 'fields_templates_and_structural_pages' && count($item->siblings("children.count>0"))>0)){
                    if(!in_array($item->name, $pages_array)){
                        $a['pages'][] = $this->pageToArray($item, 'pages', null, $i);
                        $pages_array[] = $item->name;
                    }
                }
            }

            //Templates
            if(!in_array($item->template->name, $templates_array)){
                $a['templates'][] = $this->pageToArray($item, 'templates', null, $i);
                $templates_array[] = $item->template->name;
                $this->templateFiles[] = $this->templates->get($item->template->name)->filename;
            }

            //Fields
            foreach($this->templates->get($item->template->name)->fields as $field){

                if(!in_array($field->name, $fields_array) || (array_key_exists($item->template->name, $current_template) && !in_array($field->name, $current_template[$item->template->name]))){
                    // if it's a repeater field then need to look through its subfields and add those to array if not already present
                    if($field->type=="FieldtypeRepeater"){
                        foreach($field->repeaterFields as $repeaterField){
                            $repeater_subfield = $this->fields->get($repeaterField);
                            if(!in_array($repeater_subfield->name, $fields_array)){
                                $a['fields'][] = $this->pageToArray($repeater_subfield, 'fields', null, $i);
                                $fields_array[] = $repeater_subfield->name;
                            }
                        }
                    }

                    // if it's a page field then need to add the selectable pages, templates, and fields to array if not already present
                    if($field->type=="FieldtypePage"){
                        $pagefield_template = $this->templates->get($field->template_id);
                        foreach($pagefield_template->fields as $page_selectable_field){

                            // pagefield parent page
                            $parent_page = $this->pages->get($field->parent_id);
                            if(!in_array($parent_page->name, $pages_array)){
                                $a['pages'][] = $this->pageToArray($parent_page, 'pages', null, $i); // this needs to be changed to 1 if we want to set the original parent, but this has problems too - not sure of the best solution for this yet.
                                $pages_array[] = $parent_page->name;
                            }

                            // pagefield child pages
                            $child_pages = $parent_page->children("include=all");
                            foreach($child_pages as $child_page){
                                if(!in_array($child_page->name, $pages_array)){
                                    $a['pages'][] = $this->pageToArray($child_page, 'pages', null, 1); // 1 is forced to ensure parent_name is not set to blank in pageToArray function - could be anything here but 0
                                    $pages_array[] = $child_page->name;
                                }
                            }

                            // pagefield parent and child templates
                            if(!in_array($pagefield_template->name, $templates_array)){
                                $a['templates'][] = $this->pageToArray($parent_page, 'templates', null, $i);
                                $a['templates'][] = $this->pageToArray($child_page, 'templates', null, $i);
                                $templates_array[] = $pagefield_template->name;
                            }

                            // pagefield parent fields
                            foreach($parent_page->template->fields as $pagefield_parent_field){
                                if(!in_array($pagefield_parent_field->name, $fields_array)){
                                    $a['fields'][] = $this->pageToArray($pagefield_parent_field, 'fields', $parent_page->template->name, $i);
                                    $fields_array[] = $pagefield_parent_field->name;
                                }
                            }

                            // pagefield child fields
                            if(!in_array($page_selectable_field->name, $fields_array)){
                                $a['fields'][] = $this->pageToArray($page_selectable_field, 'fields', $pagefield_template->name, $i);
                                $fields_array[] = $page_selectable_field->name;
                            }
                        }
                    }

                    $a['fields'][] = $this->pageToArray($field, 'fields', $item->template->name, $i);
                    $fields_array[] = $field->name;


                }
                $current_template[$item->template->name][] = $field->name; // this seems a little ugly - uncomment the print_r below to see the array - way more repetition than needed
            }
            $i++;

        }
        //print_r($current_template);

        //Create zip of attached files
        $allfiles = array();
        $i=0;
        foreach($this->pageFiles as $filespath => $pagepath){
            //foreach($fields as $files){
                //foreach($files as $file){
                //error_log('FP:'.$filespath.':'.$pagepath);

                /*foreach (glob($filespath.'*.*') as $file){
                    $allfiles[$i]['newpath'] = 'pages' . $pagepath . pathinfo($file, PATHINFO_BASENAME);
                    $allfiles[$i]['currentpath'] = $file;
                    $i++;
                }*/

                $dir = new DirectoryIterator($filespath);
                foreach($dir as $file) {
                    if($file->isDir() || $file->isDot()) continue;
                    $allfiles[$i]['newpath'] = 'pages' . $pagepath . $file->getBasename();
                    $allfiles[$i]['currentpath'] = $file->getPathname();
                    $i++;
                }


            //}
        }

        $this->create_zip($allfiles,$this->page->filesManager()->path().'files.zip', 'files');

        //Add required template files to zip
        $allfiles = array();
        foreach($this->templateFiles as $file){
            $allfiles[$file]['newpath'] = 'templates/' . pathinfo($file, PATHINFO_BASENAME);
            $allfiles[$file]['currentpath'] = $file;
        }
        $this->create_zip($allfiles,$this->page->filesManager()->path().'files.zip', 'files');

        return json_encode($a);
    }


    /**
     * Prepare arrays to convert to JSON
     *
     */
    protected function pageToArray($page, $type, $template_name = null, $pageNum = 0) {

        if($type == 'pages'){

            $data = array(
                'name' => $page->name,
                'parent_name' => $pageNum == 0 ? '' : $this->removeParentFromPath($page->parent->path, $this->session->treeParent.'/', 'export'),
                'page_template' => $page->template->name,
                'status' => $page->status,
                'sort' => $page->sort,
                'sortfield' => $page->sortfield,
                'data' => array(),
            );

            foreach($page->template->fieldgroup as $field) {

                $value = $page->get($field->name);
                $final_value = $field->type->sleepValue($page, $field, $value);

                if(is_array($final_value)){
                    if($field->type instanceof FieldtypeFile){ //file and image fields
                        $data['data'][(string) $field] = $final_value;
                        //add files/images to $pageFiles array for later inclusion in export zip
                        //if(!empty($final_value)) $this->pageFiles[$page->path][] = $this->getFullNamedPath($final_value, $field, $page);
                        if(!empty($final_value)) $this->pageFiles[$page->filesManager()->path()] = $page->path;
                    }
                    elseif($field->type == "FieldtypePage"){ // this is to convert page field selected IDs into names
                        $data['data'][(string) $field] = $this->getPageFieldNameFromID($this->abstractedLinkDecoder($final_value));
                    }
                    //if(array_key_exists('data', $final_value) && array_key_exists('count', $final_value) && array_key_exists('parent_id', $final_value) && $this->modules->isInstalled("LanguageSupport")) { // the data, count and parent_id checks together should limit this to repeater field data
                    elseif($field->type == "FieldtypeRepeater"){
                        $data['data'][(string) $field] = $this->getRepeaterContentFromIDs($this->abstractedLinkDecoder($final_value), $field, $page);
                    }
                    elseif(array_key_exists('data', $final_value)){ // I think this should be just multilanguage versions of field data - is there a better way to check?
                        $data['data'][(string) $field] = $this->getLanguageNameFromID($this->abstractedLinkDecoder($final_value));
                    }
                }
                else {
                    $data['data'][(string) $field] = $this->nameImagePathId($this->abstractedLinkDecoder($final_value), $page->path);
                }

            }

        }


        if($type == 'templates'){

            $data = array(
                'template' => $page->template->name,
            );

            foreach($page->template->getArray() as $field => $value) {
                //Roles (Access Tab)
                if(stripos($field,'Roles') !== false  && (is_array($value) && !empty($value) && $value[0] != 0)) {
                    $names = array_map(array($this, 'getRoleNameFromID'), $value);
                    $data['data'][$field] = $names;
                }
                //Child and Parent template settings (Family Tab)
                elseif(is_array($value) && !empty($value) && $value[0] != 0) { //Last check to hopefully deal with an error when childTemplates or parentTemplates somehow ended up as [0] => 0
                    $names = array_map(array($this, 'getTemplateNameFromID'), $value);
                    $data['data'][$field] = $names;
                }
                else{
                    $data['data'][$field] = $value;
                }
            }
        }


        if($type == 'fields'){

            $data = array(

                'name' => $page->name,
                'label' => $page->label,
                'description' => $page->description,
                'template' => $template_name,
                'flags' => $page->flags,
                'type' => "{$page->type}",

            );

            foreach($page->getArray() as $field => $value) {

                if(is_array($value) && !empty($value) && $value[0] != 0) { //Last check to hopefully deal with an error when childTemplates or parentTemplates somehow ended up as [0] => 0
                    $names = array_map(array($this, 'getFieldNameFromID'), $value);
                    $data['data'][$field] = $names;
                }
                else{
                    if($field == "parent_id"){ // convert page id to name for page field selectable parent
                        $data['data'][$field] = $this->pages->get($value)->name;
                    }
                    elseif($field == "template_id"){ // convert template id to name for page field selectable template
                        $data['data'][$field] = $this->templates->get($value)->name;
                    }
                    else{
                        $data['data'][$field] = $value;
                    }
                }
            }

        }
        return $data;
    }




    /**
     * Provide the completion output markup for processImportForm2
     *
     */
    protected function processImportForm2Markup($numImported, $imported_parent_id) {
        $out = '';
        if($imported_parent_id){
            $out .= "<h2>Created all required templates and fields and imported $numImported pages</h2>" .
            "<p><a href='{$this->config->urls->admin}page/list/?open={$imported_parent_id}'>View the imported page tree</a></p>";
        }
        else{
            $out .= "<h2>Created all required templates and fields</h2>";
        }

        $out .= "<p><strong>The following template files were migrated. If any of them contain includes, you'll need to manually copy these across to this new PW install</strong></p><p>";
        foreach($this->migratedTemplateFileNames as $templateFileName) $out .= $templateFileName.'<br />';

        $out .= "<p><a href='../import/'>Import more content</a></p>";

        return $out;
    }



    /**
     * Add a submit button, moved to a function so we don't have to do this several times
     *
     */
    protected function addSubmit(InputfieldForm $form, $value = 'Submit') {
        $f = $this->modules->get("InputfieldSubmit");
        $f->name = 'submit';
        $f->value = $value;
        $form->add($f);
    }


    /**
     * Remove the parent section from the URL path of a page
     *
     */
    protected function removeParentFromPath($path, $parent, $importOrExport){
        if($importOrExport == 'import'){
            $parent_path = $this->pages->get("$parent")->path;
            $returned_path = str_replace($parent_path, '/', $path) . '/';
            $returned_path = str_replace('//', '/', $returned_path);
            $returned_path = str_replace('/home/', '', $returned_path);
            return $returned_path;
        }
        else{
            /*$parts = explode('/', substr($path, 1));
            if(count($parts)>2) array_shift($parts);
            return str_replace('home','',implode('/', $parts));*/
            //return preg_replace("/","",$path, 1);
            return ltrim($path, '/');
        }

        /*if($importOrExport == 'import' && $this->pages->get($parent)->path == '/'){
            return $path;
        }
        else{
            $parts = explode('/', substr($path, 1));
            if(count($parts)>2) array_shift($parts);
            error_log('RETURN:'.str_replace('home','',implode('/', $parts)));
            return str_replace('home','',implode('/', $parts));
        }*/
    }

    /**
     * Return template name from its ID
     *
     */
    public function getTemplateNameFromID($id){
        if($this->templates->get($id)) return $this->templates->get($id)->name;
    }

    /**
     * Return role name from its ID
     *
     */
    public function getRoleNameFromID($id){
        if($this->roles->get($id)) return $this->roles->get($id)->name;
    }

    /**
     * Return role ID from its name
     *
     */
    public function getRoleIDFromName($name){
        //check to see if the role already exists in destination PW install. If not, add the new role and return its ID
        if($name != '' && $this->roles->get($name)->id){
            return $this->roles->get($name)->id;
        }
        else{
            //return $this->roles->get("guest")->id;
            $newrole = new Role();
            $newrole->name= $name;
            $newrole->save();
            return $newrole->id;
        }
    }

    /**
     * Return field name from its ID
     *
     */
    public function getFieldNameFromID($id){
        if($this->fields->get($id)) return $this->fields->get($id)->name;
    }

    /**
     * Return field ID from its name
     *
     */
    public function getFieldIDFromName($name){
        if($this->fields->get($name)) return $this->fields->get($name)->id;
    }

    /**
     * Return template ID from its name
     *
     */
    public function getTemplateIDFromName($name){
        if($name != '' && $this->templates->get($name)) return $this->templates->get($name)->id;
    }


    public function isImgVarOf($origImage, $compareImage){
        $re =   '/^'  .
            pathinfo($origImage, PATHINFO_FILENAME) . '\.' .      // myfile.
            '(\d+)x(\d+)' .         // 50x50
            '([pd]\d+x\d+|[a-z]{1,2})?' .   // nw or p30x40 or d30x40
            '\.' . pathinfo($origImage, PATHINFO_EXTENSION) .       // .ext
            '$/';

        if(preg_match($re, $compareImage)) {
            return true;
        }
    }


    /**
     * Return repeater field content from its array of IDs
     *
     */
    public function getRepeaterContentFromIDs( $array, $field, $page ){
        $newArray = array();
        foreach($array as $key=>$value) {
            if($key == 'data'){
                $i=0;
                foreach(explode(',',$value) as $pageid){
                    $fieldpage = $this->pages->get($pageid);
                    foreach($fieldpage->template->fields as $repeaterField){
                        if($repeaterField->type instanceof FieldtypeFile){
                            $this->pageFiles[$fieldpage->filesManager()->path()] = $page->path.$field->name.'_'.$i.'/';
                            foreach($fieldpage->{$repeaterField->name} as $file){
                                $newArray[$i][$repeaterField->name][] = $file->getArray();
                            }
                        }
                        else{
                            $newArray[$i][$repeaterField->name] = $fieldpage->{$repeaterField->name};
                        }
                    }
                    $i++;
                }
            }
        }
        return $newArray;
    }

    /**
     * Return named path for files based on the path of the page and its filename ($value['data'])
     *
     */
    /*public function getFullNamedPath( $array, $field, $page ){
        $newArray = array();

        foreach($array as $value) {
            $newArray[] = $page->filesManager()->path() . $value['data'];

            //add all versions of FieldtypeCropImage images from the Thumbnails module
            if($field->thumbSetting){
                $crops = $field->thumbSetting;
                $crops_a = explode("\n", $crops);
                foreach($crops_a as $crop) {
                    $crop = explode(',', $crop);
                    $name = wire('sanitizer')->name($crop[0]);
                    if(!strlen($name)) continue;
                    $cropFilename = $page->filesManager()->path() . $name . '_' . $value['data'];
                    if(is_file($cropFilename)) {
                        $newArray[] = $cropFilename;
                    }
                }
            }
        }

        return $newArray;
    }*/

    /**
     * Return language name from its ID
     *
     */
    public function getLanguageNameFromID( $array ){
        $newArray = array();

        foreach($array as $key=>$value) {
            $language_id = preg_replace("/[^0-9]/", "", $key); //strips out 'data' from the language name leaving just the language id
            $newArray[$language_id ? $this->languages->get($language_id)->name : 'default'] = $this->abstractedLinkDecoder($value);
        }

        return $newArray;
    }


    /**
     * Return page name from its ID - used for page field selected items
     *
     */
    public function getPageFieldNameFromID( $array ){
        $newArray = array();

        foreach($array as $value) {
            $newArray[] = $this->pages->get($value)->name;
        }

        return $newArray;
    }

    /**
     * Return page ID from its name - used for page field selected items
     *
     */
    public function getPageFieldIDFromName( $array, $fieldname ){

        //make sure we are getting a page from the pagefields available page parent / template
        $pagefield = $this->fields->get($fieldname);
        $pf_parent_id = $pagefield->parent_id ? ", parent={$pagefield->parent_id}" : "";
        $pf_template_id = $pagefield->template_id ? ", template={$pagefield->template_id}" : "";

        $newArray = array();
        foreach($array as $value) {
            $newArray[] = $this->pages->get("name={$value}{$pf_parent_id}{$pf_template_id}")->id;
        }

        return $newArray;
    }


    /**
     * Returns field with embedded links converted to format for compatibility with PageLinkAbstractor module (for import process)
     *
     */
    public function abstractedLinkEncoder($value) {

        if(!$this->modules->get("PageLinkAbstractor")) return $value;

        $rootUrl = $this->config->urls->root;

        // check if the value has links by looking for equals sign and quote
        if(strpos($value, '="') || strpos($value, "='") || strpos($value, "=$rootUrl")) {

            // replace root url with tag, should work with images or tags
            $value = preg_replace('{(=["\']?)' . preg_quote($rootUrl) . '}', '$1{~root_url}', $value);

            // replace page URLs
            if(preg_match_all('|\{~root_url\}([-_./a-zA-Z0-9]+)|', $value, $matches)) {
                $assetsUrl = $this->config->urls->assets;
                foreach($matches[1] as $key => $url) {
                    if(strpos($url, $assetsUrl) !== false) continue;
                    $p = $this->pages->get("/$url");
                    if($p->id) $value = str_replace($matches[0][$key], '{~page_' . $p->id . '_url}', $value);
                }
            }

        }

        return $value;

    }

    /**
     * Returns RTE field with links to embedded images renamed to replace page ID with the path of the page so it can be converted on import at destination PW install
     *
     */
    public function nameImagePathId($html, $pagepath){
        if (strpos($html,'<img') === false) return $html; //return early if no images are embedded in html
        $dom = new DOMDocument();
        $dom->loadHTML($html);
        foreach ($dom->getElementsByTagName('img') as $img) {
            $img->setAttribute( 'src', $pagepath . pathinfo($img->getAttribute('src'), PATHINFO_BASENAME));
        }
        return $dom->saveHTML();
    }


    /**
     * Returns RTE field with links to embedded images renamed to replace the path of the page with the assets/files/xxx so it will work at destination PW install
     *
     */
    public function idImagePath($html, $page){
        if (strpos($html,'<img') === false) return $html; //return early if no images are embedded in html
        $dom = new DOMDocument();
        $dom->loadHTML($html);
        foreach($dom->getElementsByTagName('img') as $img){
            $img->setAttribute('src', $page->filesManager()->url() . pathinfo($img->getAttribute('src'), PATHINFO_BASENAME));
        }
        return $dom->saveHTML();
    }


    /**
     * Returns field with absatracted links converted back to normal urls (for export process)
     *
     */
    public function abstractedLinkDecoder($value) {

        if(!$this->modules->get("PageLinkAbstractor")) return $value;

        $changes = 0;
        $errors = array();

        if(strpos($value, '{~page_') !== false) {
            if(preg_match_all('/\{~page_(\d+)_url\}/', $value, $matches)) {
                foreach($matches[1] as $key => $id) {
                    $p = $this->pages->get((int) $id);
                    if(!$p->id) {
                        // notify editor that they have an invalid link
                        $errors[] = "Links to page ID $id that does not exist";
                        continue;
                    }
                    if($p->isTrash()) {
                        // notify editor tthat they are linking to a page in the trash
                        $errors[] = "Links to page ID $id that is in the trash";
                        continue;
                    }
                    $value = str_replace($matches[0][$key], $p->url, $value);
                    $changes++;
                }
            }
        }

        if(strpos($value, '{~root_url}') !== false) {
            $value = str_replace('{~root_url}', $this->config->urls->root, $value);
            $changes++;
        }

        if(count($errors)) {
            $page = $arguments[0];
            if($page->editable()) {
                foreach($errors as $error) $this->error("Page {$page->path} $error");
            }
        }
        else{
            return $value;
        }

    }



    /**
     * Create zip archive of attached files for migration
     *
     */
    function create_zip($files = array(), $destination = '', $filetype, $overwrite = false) {
        //if the zip file already exists and overwrite is false, return false
        //if(file_exists($destination) && !$overwrite) return false;
        $valid_files = array();
        if(is_array($files)) {
            foreach($files as $file) {
                if(file_exists($file['currentpath'])) $valid_files[] = $file;
            }
        }
        if(count($valid_files)) {
            //create the archive
            $zip = new ZipArchive();
            if($zip->open($destination, $overwrite ? ZIPARCHIVE::OVERWRITE : ZIPARCHIVE::CREATE) !== true) return false;
            //add the files
            if($filetype == 'files'){
                foreach($valid_files as $path => $file) {
                    $zip->addFile($file['currentpath'],$file['newpath']);
                }
            }
            elseif($filetype == 'json'){
                foreach($valid_files as $file) {
                    $zip->addFile($file, pathinfo($file, PATHINFO_BASENAME));
                }
            }
            //echo 'The zip archive contains ',$zip->numFiles,' files with a status of ',$zip->status;
            $zip->close();

            //check to make sure the file exists
            return file_exists($destination);
        }
        else{
            return false;
        }
    }


    /**
     * Function to recursively delete an entire folder
     *
     */
    public function recursiveDelete($str){
        if(is_file($str)){
            return @unlink($str);
        }
        elseif(is_dir($str)){
            $scan = glob(rtrim($str,'/').'/*');
            foreach($scan as $index=>$path){
                $this->recursiveDelete($path);
            }
            return @rmdir($str);
        }
    }



    /**
     * Install the module and create the page where it lives
     *
     */
    public function ___install() {

        if(ProcessWire::versionMajor == 2 && ProcessWire::versionMinor < 1) {
            throw new WireException("This module requires ProcessWire 2.1 or newer");
        }

        $page = $this->getInstalledPage();
        $this->message("Installed to {$page->path}");
        if($page->parent->name == 'setup') $this->message("Click to your 'Setup' page to start using the Page Tree Migrator");
    }

    /**
     * Return the page that this Process is installed on
     *
     */
    protected function getInstalledPage() {

        $admin = $this->pages->get($this->config->adminRootPageID);
        $parent = $admin->child("name=setup");
        if(!$parent->id) $parent = $admin;
        $page = $parent->child("name=" . self::adminPageName);

        if(!$page->id) {
            $page = new Page();
            $page->parent = $parent;
            $page->template = $this->templates->get('admin');
            $page->name = self::adminPageName;
            $page->title = "Page Tree Migrator";
            $page->process = $this;
            $page->sort = $parent->numChildren;
            $page->save();
        }

        return $page;
    }

    /**
     * Uninstall the module
     *
     */
    public function ___uninstall() {
        $page = $this->getInstalledPage();
        if($page->id) {
            $this->message("Removed {$page->path}");
            $this->pages->delete($page);
        }
    }

}
