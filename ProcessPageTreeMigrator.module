<?php

/**
 * ProcessWire Page Tree Migrator
 * by Adrian Jones
 *
 * Allows automated migration and sharing of page trees along with their templates and fields.
 *
 * ProcessWire 2.x
 * Copyright (C) 2011 by Ryan Cramer
 * Licensed under GNU/GPL v2, see LICENSE.TXT
 *
 * http://www.processwire.com
 * http://www.ryancramer.com
 *
 */

class ProcessPageTreeMigrator extends Process implements Module {

    /**
     * getModuleInfo is a module required by all modules to tell ProcessWire about them
     *
     * @return array
     *
     */
    public static function getModuleInfo() {
        return array(
            'title' => 'Page Tree Migrator',
            'version' => 50,
            'summary' => 'Automated migrate page trees (including their templates and fields) from one PW installation to another',
            'singular' => true,
            'autoload' => false,
            );
    }

    /**
     * Name used for the page created in the admin
     *
     */
    const adminPageName = 'page-tree-migrator';


    protected $pageFiles = array();
    protected $repeaterSubFields = array();
    protected $templateFiles = array();
    protected $migratedTemplateFileNames = array();

    protected $zipFilename = '';
    protected $jsonFilename = '';
    protected $migratorFilesDir = '';
    protected $newPage = '';
    protected $newField = '';

    /**
     * Instance of Template, used for imported pages
     *
     */
    protected $template = null;

    /**
     * Instance of Page, representing the parent Page for imported pages
     *
     */
    protected $parent = null;

    /**
     * Initialize the module
     *
     */
    public function init() {
        parent::init();
        ini_set('auto_detect_line_endings', true);
    }

    /**
     * Executed when root url for module is accessed
     *
     */
    public function ___execute() {

        $form = $this->buildForm1();
        if($this->input->post->submit) {
            if($this->processForm1($form) || $this->processExportForm2($form) || $this->processImportForm2($form)) $this->session->redirect('./'.$this->input->post->type.'/');
        }
        return $form->render();
    }

    /**
     * Executed when ./export/ url for module is accessed
     *
     */
    public function ___executeExport() {

        $form = $this->buildExportForm2();
        if($this->input->post->submit) {
            return $this->processExportForm2($form);
        } else {
            $form = $this->buildExportForm2();
            return $form->render();
        }
    }


    /**
     * Executed when ./import/ url for module is accessed
     *
     */
    public function ___executeImport() {

        $form = $this->buildImportForm2();
        if($this->input->post->submit) {
            return $this->processImportForm2($form);
        } else {
            $form = $this->buildImportForm2();
            return $form->render();
        }

    }




/**
     * Build the "Step 1" form
     *
     */
    protected function buildForm1() {

        $form = $this->modules->get("InputfieldForm");
        $form->method = 'post';
        $form->description = "Step 1: Export or Import";

        $f = $this->modules->get("InputfieldSelect");
        $f->name = 'type';
        $f->label = 'Export or Import';
        $f->required = true;
        $f->addOption('');
        $f->addOption('export', 'Export');
        $f->addOption('import', 'Import');
        if($this->session->type) $f->attr('value', $this->session->type);
        $form->add($f);

        $this->addSubmit($form, 'Continue to Step 2');

        return $form;
    }



    /**
     * Process the "Step 1" form and populate session variables with the results
     *
     */
    protected function processForm1(InputfieldForm $form) {

        $form->processInput($this->input->post);
        if(count($form->getErrors())) return false;

        $this->session->type = (int) $form->get('type')->value;

        $type = $form->get('type')->value;

        if(!$type) {
            $this->error("Missing required Export/Import action type");
            return false;
        }

        $this->session->type = $type;
        return true;
    }




    /**
     * Build the "Export Step 2" form
     *
     */
    protected function buildExportForm2() {

        $form = $this->modules->get("InputfieldForm");
        $form->method = 'post';
        $form->description = "Step 2: Export Page Tree";

        $f = $this->modules->get("InputfieldPageListSelect");
        $f->name = 'treeParent';
        $f->label = 'Parent Page';
        $f->required = true;
        $f->description = "The parent of the page tree you want to export.";
        if($this->session->treeParent) $f->attr('value', $this->session->treeParent);
        $form->add($f);

        $f = $this->modules->get("InputfieldSelect");
        $f->name = 'export_components';
        $f->label = 'Components to export';
        $f->required = true;
        $f->addOption('');
        $f->addOption('everything', 'Everything, including all data pages');
        $f->addOption('fields_templates_and_structural_pages', 'Fields, Templates and Structural Pages');
        $f->addOption('fields_and_templates_only', 'Fields and Templates Only');
        if($this->session->export_components) $f->attr('value', $this->session->export_components);
        $form->add($f);

        $f = $this->modules->get("InputfieldSelect");
        $f->name = 'save_or_copy';
        $f->label = 'Output Format';
        $f->description = "SAVE zip file to your computer OR display code so you can COPY and then paste into new site.\nNB Copy will not work for migrating full page content if there are included files/images. It also won't migrate required template files.";
        $f->required = true;
        $f->addOption('');
        $f->addOption('save', 'Save');
        $f->addOption('copy', 'Copy');
        if($this->session->save_or_copy) $f->attr('value', $this->session->save_or_copy);
        $form->add($f);


        $f = $this->modules->get("InputfieldAsmSelect");
        $f->name = 'helper_files';
        $f->label = 'Helper Files';
        $f->description = "Determines which additional helper files (inc, css, js etc) will be included in the export. These will be in addition to the required template php files needed for the templates, which will automatically be included.";
        $f->showIf = "save_or_copy=save";

        foreach($iterator = new RecursiveIteratorIterator(new RecursiveDirectoryIterator($this->config->paths->templates, RecursiveDirectoryIterator::SKIP_DOTS), RecursiveIteratorIterator::SELF_FIRST) as $item){
            if ($item->isDir()) {
                //$f->addOption($iterator->getSubPathName(), $iterator->getSubPathName());
            }
            else {
                $f->addOption($iterator->getSubPathName(), $iterator->getSubPathName());
            }
        }

        $form->add($f);


        $this->addSubmit($form, 'Export');

        return $form;
    }

    /**
     * Process the "Step 2" form and populate session variables with the results
     *
     */
    protected function processExportForm2(InputfieldForm $form) {

        $this->session->treeParent = (int) $this->input->treeParent;
        $this->session->export_components = $this->input->export_components;
        $this->session->save_or_copy = $this->input->save_or_copy;
        $this->session->helper_files = $this->input->helper_files;

        $form->processInput($this->input->post);

        if(count($form->getErrors())){

            if(!$this->input->treeParent) $this->error("You did not select a parent page. This must be selected to define the content to export.");
            if(!$this->input->export_components) $this->error("You did not select the export components.");
            if(!$this->input->save_or_copy) $this->error("You did not choose an output format.");

            $this->session->redirect('./'.$this->input->post->type);
        }


        //find all the relevant pages under the selected parent and then sort them by child level (count path segments) to make sure parents are added to the JSON before their children
        $items = $this->pages->get($this->session->treeParent)->find("id!=2, id!=7, has_parent!=2, has_parent!=7, template!=admin, sort=id, include=all"); // exclude admin and trash in case the user chooses the 'Home' as the parent
        // create empty page array
        $res = new PageArray();
        foreach($items as $item) {
            // temporarily add pathsegments property to items
            $item->pathsegments = count(explode('/',$item->path));
            $res->add($item);
        }
        $items = $res->filter("sort=pathsegments");


        $parent_item = $this->pages->get($this->session->treeParent);
        $items->prepend($parent_item);

        if($this->session->save_or_copy == 'copy'){
            return '<p><textarea rows="10" style="width:95%">' . $this->pagesToJSON($items, $this->session->export_components) . '</textarea></p><p>Copy this text and import it into your new site using the paste option.</p><p><a href="../export/">Export more pages</a></p>';
        }
        else{
            $this->jsonFilename = $this->page->filesManager()->path() . 'data.json';
            //header('Content-disposition: attachment; filename='.$this->pages->get($this->session->treeParent)->name.'.json');
            //header('Content-type: application/json');
            //echo ($this->pagesToJSON($items, $this->session->export_components));
            //exit;

            //write json file to assets folder and add it to the zip download
            file_put_contents($this->jsonFilename, $this->pagesToJSON($items, $this->session->export_components));
            $allfiles = array($this->jsonFilename);
            $this->create_zip($allfiles, $this->page->filesManager()->path().'files.zip', 'json');
            unlink($this->jsonFilename);

            //download the zip to the users
            $this->zipFilename = $this->page->filesManager()->path().'files.zip';
            if (file_exists($this->zipFilename)) {
                header('Content-Description: File Transfer');
                header('Content-Type: application/zip');
                header('Content-Disposition: attachment; filename='.basename($this->zipFilename));
                header('Expires: 0');
                header('Cache-Control: must-revalidate');
                header('Pragma: public');
                header('Content-Length: ' . filesize($this->zipFilename));
                ob_clean();
                flush();
                readfile($this->zipFilename);
                unlink($this->zipFilename);
                exit;
            }
        }

    }

    /**
     * Build the "Import Step 2" form to import the json file
     *
     */
    protected function buildImportForm2() {

        $form = $this->modules->get("InputfieldForm");
        $form->method = 'post';
        $form->description = "Step 2: Import Page Tree";

        $f = $this->modules->get("InputfieldPageListSelect");
        $f->name = 'import_to_parent';
        $f->label = 'Parent Page';
        $f->description = "The parent that you want the imported pages added to.\r\nNB This is not required if you choose 'Fields and Templates Only' from the options below.";
        if($this->session->import_to_parent) $f->attr('value', $this->session->import_to_parent);
        $form->add($f);

        $f = $this->modules->get("InputfieldSelect");
        $f->name = 'import_components';
        $f->label = 'Components to Import';
        $f->required = true;
        $f->addOption('everything', 'Everything, including all data pages');
        //$f->addOption('fields_templates_and_structural_pages', 'Fields, Templates and Structural Pages');
        $f->addOption('fields_and_templates_only', 'Fields and Templates Only');
        if($this->session->import_components) $f->attr('value', $this->session->import_components);
        $form->add($f);

        $f = $this->modules->get("InputfieldSelect");
        $f->name = 'import_type';
        $f->label = 'Import Type';
        $f->required = true;
        $f->addOption('append', 'Append');
        $f->addOption('overwrite', 'Overwrite');
        $f->addOption('replace', 'Replace');
        $f->description = "APPEND will not change settings of existing fields, nor the content of existing pages. It will append new fields to templates and new pages (and date) to the selected Parent Page.\nOVERWRITE will change field settings and edit the content of existing pages so they match the imported data.\nREPLACE will match the destination to the source exactly, by modifying page data, changing field settings, and deleting unused fields from templates.";
        if($this->session->import_type) $f->attr('value', $this->session->import_type);
        $form->add($f);

        $f = $this->modules->get("InputfieldCheckbox");
        $f->name = 'user_details';
        $f->label = 'Import User Details';
        $f->description = "Determines whether to migrate the original createdUser and modifiedUser for each page.";
        $f->attr('checked', $this->session->user_details == '1' ? 'checked' : '' );
        //$f->collapsed = Inputfield::collapsedBlank;
        $f->collapsed = $f->attr('checked') ? Inputfield::collapsedNo : Inputfield::collapsedYes;
        $form->add($f);

        $f = $this->modules->get("InputfieldCheckbox");
        $f->name = 'page_dates';
        $f->label = 'Import Created / Modified Dates';
        $f->description = "Determines whether to migrate the original created and modified dates for each page.";
        $f->attr('checked', $this->session->page_dates == '1' ? 'checked' : '' );
        //$f->collapsed = Inputfield::collapsedBlank;
        $f->collapsed = $f->attr('checked') ? Inputfield::collapsedNo : Inputfield::collapsedYes;
        $form->add($f);

        $fieldset = $this->modules->get("InputfieldFieldset");
        $fieldset->attr('id', 'json_source_options');
        $fieldset->label = "Data Source";
        $fieldset->description = "Choose one of the following options as the source of the data.\r\nIf you are importing \"Everything, including all data pages\" and you have files/images in the pages, then you must choose the zip upload.\r\nNB: The structure of this JSON is critical, so it is important that it was created using the export feature of this module.";
        $form->add($fieldset);

        $f = $this->modules->get("InputfieldFile");
        $f->name = 'zip_file';
        $f->label = 'Zip File Upload';
        $f->extensions = 'zip';
        $f->maxFiles = 1;
        $f->descriptionRows = 0;
        $f->overwrite = true;
        $f->collapsed = Inputfield::collapsedBlank;
        $fieldset->add($f);

        $f = $this->modules->get("InputfieldTextarea");
        $f->name = 'json_data';
        $f->label = 'Paste in JSON Data';
        $f->collapsed = Inputfield::collapsedBlank;
        $fieldset->add($f);

        $f = $this->modules->get("InputfieldSelect");
        $f->name = 'json_package';
        $f->label = 'Shared JSON packages';
        //$packages = json_decode(file_get_contents('https://raw.github.com/adrianbj/ProcessWirePageLists/master/packages.json'));
        $options  = array('http' => array('user_agent' => 'adrianbj'));
        $context  = stream_context_create($options);
        $packages = json_decode(file_get_contents('https://api.github.com/repos/adrianbj/ProcessWirePageLists/contents/', false, $context));
        if(!is_array($packages)) {
            $this->error("Github rate limit has been exceeded. Please try again shortly.");
            $f->description = __("Github rate limit has been exceeded. Please try again shortly.");
        }
        else{
            $f->addOption('');
            foreach($packages as $package){
                $package_name = pathinfo($package->html_url, PATHINFO_FILENAME);
                $package_raw_url = str_replace('//','//raw.', str_replace('blob/','',$package->html_url));
                if($package_name != 'README') $f->addOption($package_raw_url, $package_name);
            }
            if($this->session->json_package) $f->attr('value', $this->session->json_package);
            $f->description = __("Select from one of the shared JSON packages.\r\nMore details about these packages are available at the ProcessWirePageLists Github page: [https://github.com/adrianbj/ProcessWirePageLists](https://github.com/adrianbj/ProcessWirePageLists)");
        }
        $f->collapsed = Inputfield::collapsedBlank;
        $fieldset->add($f);

        $f = $this->modules->get("InputfieldURL");
        $f->name = 'json_url';
        $f->label = 'URL to JSON file';
        $f->description = "Enter a URL directly to a .json file, eg: [https://raw.github.com/adrianbj/ProcessWirePageLists/master/countries.json](https://raw.github.com/adrianbj/ProcessWirePageLists/master/countries.json)";
        $f->collapsed = Inputfield::collapsedBlank;
        $fieldset->add($f);


        $this->addSubmit($form, 'Upload and Create Content');

        return $form;
    }

    /**
     * Process the "Import Step 2" form and upload the json file
     *
     */
    protected function processImportForm2(InputfieldForm $form) {

        $form->processInput($this->input->post);
        if(count($form->getErrors())) return false;

        $this->session->import_to_parent = (int) $this->input->import_to_parent;
        $this->session->import_components = $this->input->import_components;
        $this->session->user_details = $this->input->user_details;
        $this->session->page_dates = $this->input->page_dates;
        $this->session->import_type = $this->input->import_type;


        if(!$this->session->import_to_parent && $this->session->import_components != 'fields_and_templates_only') {
            $this->error("Missing required parent page. This must be selected if you want to import the pages in addition to field and template creation.");
            $this->session->redirect('./'.$this->input->post->type);
        }

        $zipFile = $form->get('zip_file')->value;
        $jsonData = $form->get('json_data')->value;
        $jsonPackage = $form->get('json_package')->value;
        $jsonURL = $form->get('json_url')->value;


        if(count($zipFile)) {
            $zipFile = $zipFile->first();
            $zipFile->rename("data.zip");
            $this->zipFilename = $zipFile->filename;

            // extract uploaded zip to destination PW installation
            $zip = new ZipArchive;
            if($zip->open($this->zipFilename) === TRUE) {
                $this->migratorFilesDir = $this->page->filesManager()->path() . 'migratorfiles';
                $zip->extractTo($this->migratorFilesDir);
                $zip->close();
                unlink($this->zipFilename);

                // move all template files into the destination PW site's templates folder
                $srcDir = $this->migratorFilesDir . '/templates/';
                $destDir = $this->config->paths->templates.'/';

                // check write permissions on templates directory and fail with friendly error
                if(file_exists($srcDir) && !is_writable($destDir)){
                    $this->error("There are template PHP files in your import, but the templates directory is not writeable. Please change permissions and try again.");
                    $this->session->redirect('./'.$this->input->post->type);
                }

                if (file_exists($srcDir) && is_dir($srcDir) && $handle = opendir($srcDir)) {
                    /*while (false !== ($file = readdir($handle))) {
                      if (is_file($srcDir . '/' . $file)) {
                        $this->migratedTemplateFileNames[] = $file;
                        rename($srcDir . $file, $destDir . $file);
                      }
                    }
                    closedir($handle);*/
                    foreach($iterator = new RecursiveIteratorIterator(new RecursiveDirectoryIterator($srcDir, RecursiveDirectoryIterator::SKIP_DOTS), RecursiveIteratorIterator::SELF_FIRST) as $item){
                        $this->migratedTemplateFileNames[] = str_replace($this->migratorFilesDir, '', $item);
                        if ($item->isDir()) {
                            if(!file_exists($destDir . $iterator->getSubPathName())){
                                mkdir($destDir . str_replace("//", "/", $iterator->getSubPathName()));
                            }
                        }
                        else {
                            copy($item, $destDir . str_replace("//", "/", $iterator->getSubPathName()));
                        }
                    }
                }

                //populate $fp with contents of json file, extracted from uploaded zip
                $fp = file_get_contents($this->migratorFilesDir . '/data.json');
            }

        }
        else{

            if(strlen($jsonData)) {
                $json = $jsonData;
            }
            else if(strlen($jsonPackage)) {
                $json = file_get_contents($jsonPackage);
            }
            else if(strlen($jsonURL)) {
                $json = file_get_contents($jsonURL);
            }

            $this->jsonFilename = $this->page->filesManager()->path() . 'data.json';
            file_put_contents($this->jsonFilename, $json);

            //populate $fp with data from json file written to the server from pasted, or externally linked JSON file
            $fp = file_get_contents($this->jsonFilename);
            unlink($this->jsonFilename);

        }

        //if no data source provided, return an error
        if(empty($fp)){
            $this->error("Missing required ZIP or JSON Source");
            $this->session->redirect('./'.$this->input->post->type);
        }


        //populate $data with json string of all the content to be created
        $data = json_decode($fp);

        //check fieldtypes of the fields to be installed against the available ones in the destination install before attempting to save a field with a type that isn't available.
        //attempt to install it if it is available (core and those site modules that are downloaded but not installed)
        foreach($data->fields as $np){
            if(!in_array($np->type, $this->fieldtypes->getArray()) && !$this->modules->get($np->type)){
                $this->error("There is a {$np->type} field in this import, but this field type is not available in this Processwire setup. Please install the field type and try again.");
                $this->session->redirect('./'.$this->input->post->type);
            }
        }

        //cleanup to make repeaters work when using REPLACE action - PW doesn't seem to do this properly itself.
        if($this->session->import_type == "replace"){
            foreach($data->fields as $np){
                if(isset($np->data)) {
                    foreach($np->data as $np_field_name => $np_field_value){
                        if($this->modules->get($np->type) == "FieldtypeRepeater"){
                            if($this->fields->get("{$np->name}")) $current_field_id = $this->fields->get("{$np->name}")->id;
                            if(isset($current_field_id)){
                                $forfieldid = "for-field-$current_field_id";
                                $sql = "DELETE FROM pages WHERE name=:forfieldid";
                                $query = $this->wire('database')->prepare($sql);
                                $query->bindValue(':forfieldid', $forfieldid);
                                $query->execute();
                            }
                        }
                    }
                }
            }
        }


        //Templates - first iteration to create templates
        foreach($data->templates as $np){

            if(!$this->fieldgroups->{$np->template}) {
                $fg = new Fieldgroup();
                $fg->name = $np->template;
                $fg->add("title");
                $fg->save();
            }
            else{
                $fg = $this->fieldgroups->{$np->template};
            }

            if(!$this->templates->{$np->template}) {
                $template = new Template();
                $template->name = $np->template;
                $template->fieldgroup = $fg;
                $template->save();
            }
            else{
                $template = $this->templates->{$np->template};
            }

        }


        //Templates - second iteration to save settings.
        // had to separate because it isn't possible to populate childTemplates / parentTemplates arrays if the template to be set isn't created yet
        foreach($data->templates as $np){

            $template = $this->templates->{$np->template};
            $fg = $this->fieldgroups->{$np->template};

            if(isset($np->data)) {
                foreach($np->data as $np_field_name => $np_field_value){
                    //Roles (Access Tab)
                    if(stripos($np_field_name,'Roles') !== false && is_array($np_field_value)) {
                        $id = array_map(array($this, 'getRoleIDFromName'), $np_field_value);
                        if($id) $template->$np_field_name = $id;
                    }
                    //Child and Parent template settings (Family Tab)
                    elseif(is_array($np_field_value)) {
                        $id = array_map(array($this, 'getTemplateIDFromName'), $np_field_value);
                        $template->$np_field_name = $id;
                    }
                    else{
                        $template->$np_field_name = $np_field_value;
                    }
                }
            }

            $template->fieldgroup = $fg;
            $template->save();

        }



        //Fields
        $pagefield_parent_ids = array();
        $fieldsInTemplates = array();
        $repeaterFieldsInTemplates = array();
        foreach($data->fields as $np){

            $template = $this->templates->{$np->template};

            if(!$this->fields->get($np->name)){
                $field = new Field();
                $field->type = $this->modules->get($np->type);
                $field->name = $np->name;
                $field->save();
                $this->newField = true;
            }
            else{
                $field = $this->fields->get($np->name);
            }

            //this is necessary to make sure additional fields are added to DB for certain field types.
            //was getting "Unknown column 'field_images.modified'" errors if importing to new PW install before any pages with image fields had been edited and so the modified and created fields weren't being added to the database.
            $ft = $this->modules->get($np->type);
            $ft->getDatabaseSchema($field);


            if($template) { //standard fields in template, not repeater fields
                $fieldsInTemplates[$template->name][] = $field->name; //populate for later checking of fields to be deleted
            }

            if($this->newField || $this->session->import_type == "overwrite" || $this->session->import_type == "replace"){

                $field->label = $np->label;
                $field->description = $np->description;
                $field->flags = $np->flags;

                if(isset($np->data)) {
                    foreach($np->data as $np_field_name => $np_field_value){

                        if($this->modules->get($np->type) == "FieldtypeRepeater"){

                            $this->modules->get("FieldtypeRepeater"); // install repeater module if it's not already installed. Probably not needed here as we do this above already.

                            $repeater_fieldgroup = "repeater_{$np->name}";

                            if(!$this->fieldgroups->$repeater_fieldgroup) {
                                $repeater_fg = new Fieldgroup();
                                $repeater_fg->name = $repeater_fieldgroup;
                            }
                            else{
                                $repeater_fg = $this->fieldgroups->$repeater_fieldgroup;
                            }

                            if(is_array($np_field_value)) {
                                foreach($np_field_value as $rf){
                                    $repeater_fg->append($rf); // populates fieldgroups_fields with IDs of repeater subfields
                                    $repeaterFieldsInTemplates[$np->name][] = $rf; //populate repeater subfields for later checking of fields to be deleted
                                }
                            }
                            $repeater_fg->save();

                            if(!$this->templates->$repeater_fieldgroup) {
                                $repeater_template = new Template();
                                $repeater_template->name = $repeater_fieldgroup;
                                $repeater_template->flags = 8;
                                $repeater_template->noChildren = 1;
                                $repeater_template->noParents = 1;
                                $repeater_template->noGlobal = 1;
                                $repeater_template->slashUrls = 1;
                                $repeater_template->fieldgroup = $repeater_fg;
                                $repeater_template->save();
                            }
                            else{
                                $repeater_template = $this->templates->$repeater_fieldgroup;
                            }

                            // need to override these values in the JSON data because they come from the source PW install and aren't relevant here when importing
                            if($np_field_name == "template_id") $np_field_value = $repeater_template->id;
                            if($np_field_name == "parent_id") {
                                $repeater_page = "for-field-{$field->id}";
                                $np_field_value = $this->pages->get("name=$repeater_page")->id;
                            }
                        }

                        if($this->modules->get($np->type) == "FieldtypePage"){
                            // need to override these values in the JSON data because they come from the source PW install and aren't relevant here when importing
                            if($np_field_name == "template_id") $np_field_value = $this->templates->get("name=$np_field_value")->id;
                            // populate array with parent_id names for page fields so that they can be added once the parent page has been created below in the pages section
                            if($np_field_name == "parent_id") $pagefield_parent_ids[$np->name] = $np_field_value;
                        }

                        //not sure about the new addition (2014-03-15) checking for instance of FieldtypeFile ??
                        //was an attempt to fix broken image field creation, but I don't think it is related, although might still be a good check to have
                        if(is_array($np_field_value) && !$this->modules->get($np->type) instanceof FieldtypeFile) { // think this is limited to repeaters and nothing else - need to check
                            $id = array_map(array($this, 'getFieldIDFromName'), $np_field_value);
                            $field->$np_field_name = $id; // populates fields > data > repeaterFields with IDs of repeater subfields
                        }
                        else{
                            $field->$np_field_name = $np_field_value;
                        }

                    }
                }

                $field->save();
                if($template) $template->fieldgroup->append($field); // add new field to template. If $template checks are for repeater subfields - don't want to add these to a standard template
            }
            else{
                if($template) $template->fieldgroup->append($this->fields->{$np->name}); // add existing field to template - NB: this does not change any of the attributes of a field if it already exists - this could be problematic for the import
            }

            if($template) $template->fieldgroup->save();

            //$field->save();

        }



        //Remove fields no longer in templates when using the REPLACE import action
        if($this->session->import_type == "replace"){

            $templateArray = array();
            $repeaterFieldsArray = array();
            foreach($fieldsInTemplates as $check_temp => $fields){
                $templateArray[] = $check_temp;
            }

            //Normal fields
            foreach($templateArray as $template){
                if($template=='') continue; //blank template means a repeater field due to the way the JSON is contructed
                foreach($this->templates->get("$template")->fields as $des_field){
                    if(!in_array($des_field, $fieldsInTemplates[$template]) && $des_field != 'title'){
                        $this->templates->get("$template")->fieldgroup->remove($this->fields->get("$des_field"));
                        $this->templates->get("$template")->fieldgroup->save();
                    }
                }
            }

            //Repeater fields
            foreach($fieldsInTemplates as $check_temp => $fields){
                foreach($fields as $field){
                    if($this->fields->get("$field")->type == "FieldtypeRepeater") $repeaterFieldsArray[] = $field;
                }
            }

            foreach($repeaterFieldsArray as $repeaterField){
                $repTemplate = $this->templates->get("repeater_$repeaterField");
                foreach($repTemplate->fieldgroup as $rf){
                    //error_log('RFN:'.$rf->name);
                    if(!in_array($rf->name, $repeaterFieldsInTemplates[$repeaterField])){
                        $repTemplate->fieldgroup->remove($this->fields->get("$rf->name"));
                        $repTemplate->fieldgroup->save();
                    }
                }
            }
        }



        //Pages
        $i=0;
        $top_parent_page = '';

        if($this->session->import_components == 'everything'){

            if(isset($data->pages)){

                foreach($data->pages as $np){

                    $import_to_parent = $this->pages->get($form->get('import_to_parent')->value);
                    $parent = $this->pages->get($import_to_parent->path.$np->parent_name);
                    if(!$parent->id) $parent = $this->pages->get('/');

                    //if import_type is REPLACE then we need to delete all pages under the parent (hence the $i==0 check) so we end up with an exact copy of the imported site
                    if($this->session->import_type == 'replace' && $i==0){
                        $rp = $this->pages->get("name={$np->name}, template={$np->page_template}, parent=$parent");
                        if($rp->id) $this->pages->delete($rp, true);
                    }

                    if(!$this->pages->get("name={$np->name}, template={$np->page_template}, parent=$parent")->id){ //Check to see if a page with same name, template and parent already exists before creating it
                        $wp = new Page();
                        $wp->parent = $parent;
                        $wp->template = $this->templates->{$np->page_template};
                        $wp->name = $np->name;
                        $wp->of(false);
                        $this->newPage = true;
                    }
                    else{
                        $wp = $this->pages->get("name={$np->name}, template={$np->page_template}, parent=$parent");
                    }

                    $wp->save();

                    if($this->newPage || $this->session->import_type == "overwrite" || $this->session->import_type == "replace"){
                        $wp->status = $np->status;
                        $wp->sort = $np->sort;
                        if(isset($np->sortfield)) $wp->sortfield = $np->sortfield;

                        if($i==0) $top_parent_page = $wp; //Used for link to show created page tree

                        if(isset($np->data)) {
                            foreach($np->data as $np_field_name => $np_field_value){

                                if(is_object($np_field_value) && array_key_exists('default', $np_field_value)){ // this is for multi language versions of fields - the check for 'default' key should distinguish it from other fields that are objects
                                    $this->modules->get("LanguageSupport"); // install language support module if it's not already installed. Might also need to install other language modules too?
                                    foreach($np_field_value as $language => $field_value){
                                        $wp->$np_field_name->setLanguageValue($this->languages->get($language), $this->abstractedLinkEncoder($field_value));
                                    }
                                }
                                elseif(is_object($np_field_value)){ // this is for other custom fieldtypes with multiple DB fields
                                    foreach($np_field_value as $field_name => $field_value){
                                        // if conditional is required because of float fields like in MapMarker Fieldtype, otherwise error trying to insert blank value
                                        if($field_value!='') $wp->$np_field_name->$field_name = $field_value;
                                    }
                                }
                                elseif($wp->fields->get($np_field_name) && $wp->fields->get($np_field_name)->type instanceof FieldtypeFile){ // this is for file/image fields
                                    foreach($np_field_value as $file) {

                                        $tmpImgDir = $this->page->filesManager()->path().'migratorfiles/pages/'.$this->removeParentFromPath($wp->path, $this->session->import_to_parent, 'import');
                                        $tempImgDir = str_replace('//', '/', $tmpImgDir);
                                        $filepath = $tmpImgDir.$file->data;

                                        if(file_exists($filepath)){
                                            $wp->$np_field_name->add($filepath);

                                            //This was here for trying to support rename on save using Custom Upload Names when images are embedded into RTE fields.
                                            //Will revisit later
                                            /*if($wp->fields->get($np_field_name) && $wp->fields->get($np_field_name)->type instanceof FieldtypeImage){

                                                $dir = new DirectoryIterator($tmpImgDir);
                                                foreach($dir as $tmpfile) {
                                                    if($tmpfile->isDir() || $tmpfile->isDot()) continue;
                                                    if($this->isImgVarOf(pathinfo($filepath, PATHINFO_BASENAME), pathinfo($tmpImgDir.$tmpfile, PATHINFO_BASENAME))){
                                                        rename($tmpImgDir.$tmpfile, $wp->filesManager()->path() . $tmpfile);
                                                    }
                                                }
                                            }*/

                                            unlink($filepath); //remove from migratorfiles temp folder so that it won't get re-copied with the variations a little further down

                                            $wp->of(false);
                                            $wp->save($np_field_name);
                                            $wp->$np_field_name->last()->description = $file->description;
                                            if($this->fields->$np_field_name->useTags == 1) $wp->$np_field_name->last()->tags = $file->tags;
                                            $wp->save($np_field_name);
                                        }

                                        //no longer needed as all additional versions of images are now copied across anyway
                                        //copy all versions of FieldtypeCropImage images from the Thumbnails module into the final assets/files/id folder
                                        /*$field = $wp->fields->get($np_field_name);
                                        if($field->thumbSetting){
                                            $crops = $field->thumbSetting;
                                            $crops_a = explode("\n", $crops);
                                            foreach($crops_a as $crop) {
                                                $crop = explode(',', $crop);
                                                $name = wire('sanitizer')->name($crop[0]);
                                                if(!strlen($name)) continue;
                                                $cropFilename = $this->page->filesManager()->path().'migratorfiles/pages/'.$this->removeParentFromPath($wp->path, $this->session->import_to_parent, 'import') . $name . '_' . $file->data;
                                                $cropFilename = str_replace('//', '/', $cropFilename);
                                                if(is_file($cropFilename)) {
                                                    copy($cropFilename, $wp->filesManager()->path() . pathinfo($cropFilename, PATHINFO_BASENAME));
                                                }
                                            }
                                        }*/
                                    }
                                }
                                elseif($wp->fields->get($np_field_name) && $wp->fields->get($np_field_name)->type == 'FieldtypePage'){ // this is for page fields
                                    // these were breaking page fields and not needed because all of this is taken care of in the next loop further down
                                    // need to grab the first (and only item) from the return array if the page field is a single type
                                    /*if($wp->$np_field_name instanceof Page) {
                                        $wp->$np_field_name = $this->getPageFieldIDFromName($np_field_value)[0];
                                    // else add the entire array to multi page field
                                    } else if($wp->$np_field_name instanceof PageArray) {
                                        $wp->$np_field_name = $this->getPageFieldIDFromName($np_field_value);
                                    }*/
                                }
                                elseif($wp->fields->get($np_field_name) && $wp->fields->get($np_field_name)->type == 'FieldtypeRepeater'){ // this is for repeater fields
                                    $n=0;
                                    foreach($np_field_value as $subfield => $valuearray){
                                        $newrf = $wp->$np_field_name->getNew(); // getNew() is special PW helper method for creating new repeater items (http://processwire.com/api/fieldtypes/repeaters/)
                                        $newrf->save();
                                        $this->repeaterSubFields[] = $newrf;
                                        $wp->save(); //needed for repeaters with file/image fields
                                        $wp->of(false);
                                        foreach($valuearray as $field => $value){
                                            if($wp->fields->get($field) && $wp->fields->get($field)->type instanceof FieldtypeFile){ // this is for file/image fields
                                                foreach($value as $file) {
                                                    $filepath = $this->page->filesManager()->path().'migratorfiles/pages/'.$this->removeParentFromPath($wp->path, $this->session->import_to_parent, 'import').$np_field_name.'_'.$n.'/'.$file->basename;
                                                    $filepath = str_replace('//', '/', $filepath);
                                                    if(file_exists($filepath)){
                                                        $newrf->$field->add($filepath);
                                                        unlink($filepath); //remove from migratorfiles temp folder so that it won't get re-copied with the variations a little further down
                                                        $newrf->of(false);
                                                        $newrf->save($field);
                                                        $newrf->$field->last()->description = $file->description;
                                                        if($this->fields->$field->useTags == 1) $newrf->$field->last()->tags = $file->tags;
                                                        $newrf->save($field);
                                                    }
                                                }
                                            }
                                            else{
                                                $newrf->$field = $value;
                                                $newrf->save();
                                            }
                                        }
                                        $wp->save();
                                        $n++;
                                    }
                                }
                                else{
                                    $wp->$np_field_name = $this->abstractedLinkEncoder($this->idImagePath($np_field_value, $wp));
                                }
                            }
                        }


                        if($this->session->user_details == 1 || $this->session->user_details == 1){
                            //Set user details for page from export if the user_details option is selected. Quiet save is needed to allow this change
                            if($this->session->user_details == 1){
                                $wp->created_users_id = $this->getUserIDFromName($np->created_users_id);
                                $wp->modified_users_id = $this->getUserIDFromName($np->modified_users_id);
                                $wp->save(array('quiet' => true));
                            }

                            //Set modified/created date for page from export if the page_dates option is selected. Quiet save is needed to allow this change
                            if($this->session->page_dates == 1){
                                $wp->created = $np->created;
                                $wp->modified = $np->modified;
                                $wp->save(array('quiet' => true));
                            }
                        }
                        else{
                            $wp->save();
                        }

                        // move all the remaining (should be just the variations) page files into the destination PW site's assets/files/id folder
                        //normal file/image fields
                        $srcDir = $this->migratorFilesDir . '/pages/' . $this->removeParentFromPath($wp->path, $this->session->import_to_parent, 'import');
                        $srcDir = str_replace('//', '/', $srcDir);
                        $destDir = $wp->filesManager()->path();

                        if (file_exists($srcDir) && is_dir($srcDir) && $handle = opendir($srcDir)) {
                            while (false !== ($file = readdir($handle))) {
                              if (is_file($srcDir . $file)) {
                                rename($srcDir . $file, $destDir . $file);
                              }
                            }
                            closedir($handle);
                        }

                        // repeater file/image fields
                        $n=0;
                        foreach($this->repeaterSubFields as $rsf){
                            $srcDir = $this->migratorFilesDir . '/pages/' . $this->removeParentFromPath($wp->path, $this->session->import_to_parent, 'import').$np_field_name.'_'.$n.'/';
                            $srcDir = str_replace('//', '/', $srcDir);
                            $destDir = $rsf->filesManager()->path();

                            if (file_exists($srcDir) && is_dir($srcDir) && $handle = opendir($srcDir)) {
                                while (false !== ($file = readdir($handle))) {
                                  if (is_file($srcDir . $file)) {
                                    rename($srcDir . $file, $destDir . $file);
                                  }
                                }
                                closedir($handle);
                            }
                            $n++;
                        }

                    }

                    $i++;

                }

            }

        }

        //add parent_id to page fields now that the parent page has been created
        foreach($pagefield_parent_ids as $pagefield_name => $pagefield_parent_id_name){
            $pagefield = $this->fields->get($pagefield_name);
            $pagefield->parent_id = $this->pages->get("name=$pagefield_parent_id_name")->id;
            $pagefield->save();
        }

        // run through pages again to populate page field data now that the page fields selectable pages have been created
        if($this->session->import_components == 'everything'){

            if(isset($data->pages)){
                foreach($data->pages as $np){

                    $import_to_parent = $this->pages->get($form->get('import_to_parent')->value);
                    $parent = $this->pages->get($import_to_parent->path.$np->parent_name.'/');
                    if(!$parent->id) $parent = $this->pages->get('/');

                    $cp = $this->pages->get("name={$np->name}, template={$np->page_template}, parent=$parent");
                    if(!$cp->id) continue;
                    if(isset($np->data)) {
                        foreach($np->data as $np_field_name => $np_field_value){

                            if($cp->fields->get($np_field_name) && $cp->fields->get($np_field_name)->type == 'FieldtypePage'){ // this is for page fields
                                $cp->of(false);

                                $fieldid = $this->getPageFieldIDFromName($np_field_value, $np_field_name);
                                // need to grab the first [0] (and only item) from the return array if the page field is a single type
                                if($cp->$np_field_name instanceof Page) {
                                    if(is_array($np_field_value) && !empty($np_field_value)) $cp->$np_field_name = $fieldid[0];
                                // else add the entire array to multi page field
                                } else if($cp->$np_field_name instanceof PageArray) {
                                    $cp->$np_field_name = $fieldid;
                                }

                                $cp->save();
                            }
                        }
                    }
                    $cp->of(false);
                    $cp->save();
                }
            }
        }

        //remove the extracted folder of all the migrated files, templates, and json file
        if(isset($this->migratorFilesDir) && file_exists($this->migratorFilesDir)) $this->recursiveDelete($this->migratorFilesDir);

        return $this->processImportForm2Markup($i, $top_parent_page != '' ? $top_parent_page->id : false);

    }


    /**
     * Push all relevant templates, fields and pages to the pageToArray function and then JSON encode
     *
     */
    protected function pagesToJSON(PageArray $items, $export_components) {

        $a = array();
        $pages_array = array();
        $templates_array = array();
        $fields_array = array();
        $current_template = array();
        $i=0;
        foreach($items as $item) {

            //Pages
            if($export_components != 'fields_and_templates_only'){
                if($export_components == 'everything' || ($export_components == 'fields_templates_and_structural_pages' && count($item->siblings("children.count>0"))>0)){
                    if(!in_array($item->name, $pages_array)){
                        $a['pages'][] = $this->pageToArray($item, 'pages', null, $i);
                        $pages_array[] = $item->name;
                    }
                }
            }

            //Templates
            if(!in_array($item->template->name, $templates_array)){
                $a['templates'][] = $this->pageToArray($item, 'templates', null, $i);
                $templates_array[] = $item->template->name;
                $this->templateFiles[] = $this->templates->get($item->template->name)->filename;
            }

            //Fields
            foreach($this->templates->get($item->template->name)->fields as $field){

                if(!in_array($field->name, $fields_array) || (array_key_exists($item->template->name, $current_template) && !in_array($field->name, $current_template[$item->template->name]))){
                    // if it's a repeater field then need to look through its subfields and add those to array if not already present
                    if($field->type=="FieldtypeRepeater"){
                        foreach($field->repeaterFields as $repeaterField){
                            $repeater_subfield = $this->fields->get($repeaterField);
                            if(!in_array($repeater_subfield->name, $fields_array)){
                                $a['fields'][] = $this->pageToArray($repeater_subfield, 'fields', null, $i);
                                $fields_array[] = $repeater_subfield->name;
                            }
                        }
                    }

                    // if it's a page field (and the parent_id is defined) then need to add the selectable pages, templates, and fields to array if not already present
                    // the reason we require the parent_id to be set is that it doesn't make sense to migrate a collection of pages from all over a page tree - would be a mess
                    // also don't want to export the entire page tree if the page field has Home (ID:1) as the parent of selectable pages
                    if($field->type=="FieldtypePage" && $field->parent_id!="" && $field->parent_id!="1"){

                        $inputfield = $field->getInputfield($this->page);
                        $selectablePages = $inputfield->getSelectablePages($this->page);

                        foreach($selectablePages as $selectablePage){

                            foreach($selectablePage->fields as $selectablePageField){

                                $page_selectable_field = $selectablePageField;

                                if($field->template_id != ""){
                                    $pagefield_template = $this->templates->get($field->template_id);
                                }
                                else{
                                    $pagefield_template = $selectablePage->template;
                                }

                                // pagefield parent page
                                $parent_page = $this->pages->get($field->parent_id);
                                if(!in_array($parent_page->name, $pages_array)){ //check to see if this page is not already in the array of pages being exported
                                    $a['pages'][] = $this->pageToArray($parent_page, 'pages', null, $i); // this needs to be changed to 1 if we want to set the original parent, but this has problems too - not sure of the best solution for this yet.
                                    $pages_array[] = $parent_page->name;
                                }

                                // pagefield child pages
                                $child_pages = $parent_page->children("include=all");
                                foreach($child_pages as $child_page){
                                    if(!in_array($child_page->name, $pages_array)){
                                        $a['pages'][] = $this->pageToArray($child_page, 'pages', null, 1); // 1 is forced to ensure parent_name is not set to blank in pageToArray function - could be anything here but 0
                                        $pages_array[] = $child_page->name;
                                    }
                                }

                                // pagefield parent and child templates
                                if(!in_array($pagefield_template->name, $templates_array)){
                                    $a['templates'][] = $this->pageToArray($parent_page, 'templates', null, $i);
                                    $a['templates'][] = $this->pageToArray($child_page, 'templates', null, $i);
                                    $templates_array[] = $pagefield_template->name;
                                }

                                // pagefield parent fields
                                foreach($parent_page->template->fields as $pagefield_parent_field){
                                    if(!in_array($pagefield_parent_field->name, $fields_array)){
                                        $a['fields'][] = $this->pageToArray($pagefield_parent_field, 'fields', $parent_page->template->name, $i);
                                        $fields_array[] = $pagefield_parent_field->name;
                                    }
                                }

                                // pagefield child fields
                                if(!in_array($page_selectable_field->name, $fields_array)){
                                    $a['fields'][] = $this->pageToArray($page_selectable_field, 'fields', $pagefield_template->name, $i);
                                    $fields_array[] = $page_selectable_field->name;
                                }
                            }
                        }
                    }

                    $a['fields'][] = $this->pageToArray($field, 'fields', $item->template->name, $i);
                    $fields_array[] = $field->name;


                }
                $current_template[$item->template->name][] = $field->name; // this seems a little ugly - uncomment the print_r below to see the array - way more repetition than needed
            }
            $i++;

        }
        //print_r($current_template);

        if($this->session->save_or_copy == 'save'){
            //Create zip of attached files
            $allfiles = array();
            $i=0;
            foreach($this->pageFiles as $filespath => $pagepath){
                //foreach($fields as $files){
                    //foreach($files as $file){
                    //error_log('FP:'.$filespath.':'.$pagepath);

                    /*foreach (glob($filespath.'*.*') as $file){
                        $allfiles[$i]['newpath'] = 'pages' . $pagepath . pathinfo($file, PATHINFO_BASENAME);
                        $allfiles[$i]['currentpath'] = $file;
                        $i++;
                    }*/

                    $dir = new DirectoryIterator($filespath);
                    foreach($dir as $file) {
                        if($file->isDir() || $file->isDot()) continue;
                        $allfiles[$i]['newpath'] = 'pages' . $pagepath . $file->getBasename();
                        $allfiles[$i]['currentpath'] = $file->getPathname();
                        $i++;
                    }


                //}
            }

            $this->create_zip($allfiles,$this->page->filesManager()->path().'files.zip', 'files');

            //Add required template files to zip
            $allfiles = array();
            foreach($this->templateFiles as $file){
                $allfiles[$file]['newpath'] = 'templates/' . pathinfo($file, PATHINFO_BASENAME);
                $allfiles[$file]['currentpath'] = $file;
            }

            if($this->input->helper_files != ''){
                //Add additional helper files as defined during export
                foreach($this->input->helper_files as $helperfile){
                    $pathFromTemplatesDir = str_replace($this->config->paths->templates,'',$helperfile);
                    $allfiles[$helperfile]['newpath'] = 'templates/' . $pathFromTemplatesDir;
                    $allfiles[$helperfile]['currentpath'] = $helperfile;
                }
            }

            $this->create_zip($allfiles,$this->page->filesManager()->path().'files.zip', 'files');
        }

        return json_encode($a);
    }


    /**
     * Prepare arrays to convert to JSON
     *
     */
    protected function pageToArray($wp, $type, $template_name = null, $pageNum = 0) {

        if($type == 'pages'){

            $data = array(
                'name' => $wp->name,
                'parent_name' => $pageNum == 0 ? '' : $this->removeParentFromPath($wp->parent->path, $this->session->treeParent.'/', 'export'),
                'page_template' => $wp->template->name,
                'status' => $wp->status,
                'sort' => $wp->sort,
                'sortfield' => $wp->sortfield,
                'created_users_id' => $wp->createdUser->name.":".implode('|',array_map(array($this, 'getRoleNameFromID'), explode('|',$wp->createdUser->roles))),
                'modified_users_id' => $wp->modifiedUser->name.":".implode('|',array_map(array($this, 'getRoleNameFromID'), explode('|',$wp->modifiedUser->roles))),
                'created' => $wp->created,
                'modified' => $wp->modified,
                'data' => array(),
            );

            foreach($wp->template->fieldgroup as $field) {

                $value = $wp->get($field->name);
                $final_value = $field->type->sleepValue($wp, $field, $value);

                if(is_array($final_value)){
                    if($field->type instanceof FieldtypeFile){ //file and image fields
                        $data['data'][(string) $field] = $final_value;
                        //add files/images to $pageFiles array for later inclusion in export zip
                        //if(!empty($final_value)) $this->pageFiles[$wp->path][] = $this->getFullNamedPath($final_value, $field, $wp);
                        if(!empty($final_value)) $this->pageFiles[$wp->filesManager()->path()] = $wp->path;
                    }
                    elseif($field->type == "FieldtypePage"){ // this is to convert page field selected IDs into names
                        $data['data'][(string) $field] = $this->getPageFieldNameFromID($this->abstractedLinkDecoder($final_value));
                    }
                    //if(array_key_exists('data', $final_value) && array_key_exists('count', $final_value) && array_key_exists('parent_id', $final_value) && $this->modules->isInstalled("LanguageSupport")) { // the data, count and parent_id checks together should limit this to repeater field data
                    elseif($field->type == "FieldtypeRepeater"){
                        $data['data'][(string) $field] = $this->getRepeaterContentFromIDs($this->abstractedLinkDecoder($final_value), $field, $wp);
                    }
                    elseif(array_key_exists('default', $final_value)){ // I think this should be just multilanguage versions of field data - is there a better way to check?
                        $data['data'][(string) $field] = $this->getLanguageNameFromID($this->abstractedLinkDecoder($final_value));
                    }
                    elseif(array_key_exists('data', $final_value)){ // I think this should be all the remaining custom field types with multiple DB fields, like MapMarker etc
                        //override $final_value array with the module names of the subfields, rather than the DB field names
                        $final_value = array();
                        foreach($wp->{$field->name} as $subfield => $value){
                            $final_value[$subfield] = $value;
                        }
                        $data['data'][(string) $field] = $final_value;
                    }
                }
                else {
                    $data['data'][(string) $field] = $this->nameImagePathId($this->abstractedLinkDecoder($final_value), $wp->path);
                }

            }

        }


        if($type == 'templates'){

            $data = array(
                'template' => $wp->template->name,
            );

            foreach($wp->template->getArray() as $field => $value) {
                //Roles (Access Tab)
                if(stripos($field,'Roles') !== false  && (is_array($value) && !empty($value) && $value[0] != 0)) {
                    $names = array_map(array($this, 'getRoleNameFromID'), $value);
                    $data['data'][$field] = $names;
                }
                //Child and Parent template settings (Family Tab)
                elseif(is_array($value) && !empty($value) && $value[0] != 0) { //Last check to hopefully deal with an error when childTemplates or parentTemplates somehow ended up as [0] => 0
                    $names = array_map(array($this, 'getTemplateNameFromID'), $value);
                    $data['data'][$field] = $names;
                }
                else{
                    $data['data'][$field] = $value;
                }
            }
        }


        if($type == 'fields'){

            $data = array(

                'name' => $wp->name,
                'label' => $wp->label,
                'description' => $wp->description,
                'template' => $template_name,
                'flags' => $wp->flags,
                'type' => "{$wp->type}",

            );

            foreach($wp->getArray() as $field => $value) {

                if(is_array($value) && !empty($value) && $value[0] != 0) { //Last check to hopefully deal with an error when childTemplates or parentTemplates somehow ended up as [0] => 0
                    $names = array_map(array($this, 'getFieldNameFromID'), $value);
                    $data['data'][$field] = $names;
                }
                else{
                    if($field == "parent_id"){ // convert page id to name for page field selectable parent
                        $data['data'][$field] = $this->pages->get($value)->name;
                    }
                    elseif($field == "template_id"){ // convert template id to name for page field selectable template
                        $data['data'][$field] = $this->templates->get($value)->name;
                    }
                    else{
                        $data['data'][$field] = $value;
                    }
                }
            }

        }
        return $data;
    }




    /**
     * Provide the completion output markup for processImportForm2
     *
     */
    protected function processImportForm2Markup($numImported, $imported_parent_id) {
        $out = '';
        if($imported_parent_id){
            $out .= "<h2>Created all required templates and fields and imported/edited $numImported pages</h2>" .
            "<p><a href='{$this->config->urls->admin}page/list/?open={$imported_parent_id}'>View the imported page tree</a></p>";
        }
        else{
            $out .= "<h2>Created all required templates and fields</h2>";
        }

        if(count($this->migratedTemplateFileNames)>0){
            $out .= "<p><strong>The following template files were migrated. If any of them contain includes, you'll need to manually copy these across to this new PW install</strong></p><p>";
            foreach($this->migratedTemplateFileNames as $templateFileName) $out .= $templateFileName.'<br />';
        }

        $out .= "<p><a href='../import/'>Import more content</a></p>";

        return $out;
    }



    /**
     * Add a submit button, moved to a function so we don't have to do this several times
     *
     */
    protected function addSubmit(InputfieldForm $form, $value = 'Submit') {
        $f = $this->modules->get("InputfieldSubmit");
        $f->name = 'submit';
        $f->value = $value;
        $form->add($f);
    }


    /**
     * Remove the parent section from the URL path of a page
     *
     */
    protected function removeParentFromPath($path, $parent, $importOrExport){
        if($importOrExport == 'import'){
            $parent_path = $this->pages->get("$parent")->path;
            $returned_path = str_replace($parent_path, '/', $path) . '/';
            $returned_path = str_replace('//', '/', $returned_path);
            $returned_path = str_replace('/home/', '', $returned_path);
            return $returned_path;
        }
        else{
            /*$parts = explode('/', substr($path, 1));
            if(count($parts)>2) array_shift($parts);
            return str_replace('home','',implode('/', $parts));*/
            //return preg_replace("/","",$path, 1);
            return ltrim($path, '/');
        }

        /*if($importOrExport == 'import' && $this->pages->get($parent)->path == '/'){
            return $path;
        }
        else{
            $parts = explode('/', substr($path, 1));
            if(count($parts)>2) array_shift($parts);
            error_log('RETURN:'.str_replace('home','',implode('/', $parts)));
            return str_replace('home','',implode('/', $parts));
        }*/
    }


    /**
     * Return user ID from their username
     *
     */
    public function getUserIDFromName($userdetails){
        //check to see if the user already exists in destination PW install. If not, add the new user and return its ID

        $userRoles = str_replace(':','',strstr($userdetails, ':'));
        $name = str_replace(':','',str_replace($userRoles, '', $userdetails));

        if($name != '' && $this->users->get($name)->id){
            return $this->users->get($name)->id;
        }
        else{
            $newuser = new User();
            $newuser->name= $name;
            foreach(explode('|',$userRoles) as $userRole) $this->addCreateRole($newuser, $userRole);
            $newuser->save();
            return $newuser->id;
        }
    }


    public function addCreateRole($newuser, $userrole){
        //check to see if the role already exists in destination PW install. If not, add the new role and add it to the supplied user
        if(!$this->roles->get($userrole)->id){
            $newrole = new Role();
            $newrole->name= $userrole;
            $newrole->save();
            $newuser->addRole($newrole);
        }
        $newuser->addRole($userrole);
    }


    /**
     * Return template name from its ID
     *
     */
    public function getTemplateNameFromID($id){
        if($this->templates->get($id)) return $this->templates->get($id)->name;
    }

    /**
     * Return role name from its ID
     *
     */
    public function getRoleNameFromID($id){
        if($this->roles->get($id)) return $this->roles->get($id)->name;
    }

    /**
     * Return role ID from its name
     *
     */
    public function getRoleIDFromName($name){
        //check to see if the role already exists in destination PW install. If not, add the new role and return its ID
        if($name != '' && $this->roles->get($name)->id){
            return $this->roles->get($name)->id;
        }
        else{
            //return $this->roles->get("guest")->id;
            $newrole = new Role();
            $newrole->name= $name;
            $newrole->save();
            return $newrole->id;
        }
    }

    /**
     * Return field name from its ID
     *
     */
    public function getFieldNameFromID($id){
        if($this->fields->get($id)) return $this->fields->get($id)->name;
    }

    /**
     * Return field ID from its name
     *
     */
    public function getFieldIDFromName($name){
        if($this->fields->get($name)) return $this->fields->get($name)->id;
    }

    /**
     * Return template ID from its name
     *
     */
    public function getTemplateIDFromName($name){
        if($name != '' && $this->templates->get($name)) return $this->templates->get($name)->id;
    }


    public function isImgVarOf($origImage, $compareImage){
        $re =   '/^'  .
            pathinfo($origImage, PATHINFO_FILENAME) . '\.' .      // myfile.
            '(\d+)x(\d+)' .         // 50x50
            '([pd]\d+x\d+|[a-z]{1,2})?' .   // nw or p30x40 or d30x40
            '\.' . pathinfo($origImage, PATHINFO_EXTENSION) .       // .ext
            '$/';

        if(preg_match($re, $compareImage)) {
            return true;
        }
    }


    /**
     * Return repeater field content from its array of IDs
     *
     */
    public function getRepeaterContentFromIDs( $array, $field, $wp ){
        $newArray = array();
        foreach($array as $key=>$value) {
            if($key == 'data'){
                $i=0;
                foreach(explode(',',$value) as $pageid){
                    $fieldpage = $this->pages->get($pageid);
                    if(!$fieldpage->template) continue; //checks to see if there are actually any repeater content items stored for the page
                    foreach($fieldpage->template->fields as $repeaterField){
                        if($repeaterField->type instanceof FieldtypeFile){
                            $this->pageFiles[$fieldpage->filesManager()->path()] = $wp->path.$field->name.'_'.$i.'/';
                            foreach($fieldpage->{$repeaterField->name} as $file){
                                $newArray[$i][$repeaterField->name][] = $file->getArray();
                            }
                        }
                        else{
                            $newArray[$i][$repeaterField->name] = $fieldpage->{$repeaterField->name};
                        }
                    }
                    $i++;
                }
            }
        }
        return $newArray;
    }

    /**
     * Return named path for files based on the path of the page and its filename ($value['data'])
     *
     */
    /*public function getFullNamedPath( $array, $field, $wp ){
        $newArray = array();

        foreach($array as $value) {
            $newArray[] = $wp->filesManager()->path() . $value['data'];

            //add all versions of FieldtypeCropImage images from the Thumbnails module
            if($field->thumbSetting){
                $crops = $field->thumbSetting;
                $crops_a = explode("\n", $crops);
                foreach($crops_a as $crop) {
                    $crop = explode(',', $crop);
                    $name = wire('sanitizer')->name($crop[0]);
                    if(!strlen($name)) continue;
                    $cropFilename = $wp->filesManager()->path() . $name . '_' . $value['data'];
                    if(is_file($cropFilename)) {
                        $newArray[] = $cropFilename;
                    }
                }
            }
        }

        return $newArray;
    }*/

    /**
     * Return language name from its ID
     *
     */
    public function getLanguageNameFromID( $array ){
        $newArray = array();

        foreach($array as $key=>$value) {
            $language_id = preg_replace("/[^0-9]/", "", $key); //strips out 'data' from the language name leaving just the language id
            $newArray[$language_id ? $this->languages->get($language_id)->name : 'default'] = $this->abstractedLinkDecoder($value);
        }

        return $newArray;
    }


    /**
     * Return page name from its ID - used for page field selected items
     *
     */
    public function getPageFieldNameFromID( $array ){
        $newArray = array();

        foreach($array as $value) {
            $newArray[] = $this->pages->get($value)->name;
        }

        return $newArray;
    }

    /**
     * Return page ID from its name - used for page field selected items
     *
     */
    public function getPageFieldIDFromName( $array, $fieldname ){

        //make sure we are getting a page from the pagefields available page parent / template
        $pagefield = $this->fields->get($fieldname);
        $pf_parent_id = $pagefield->parent_id ? ", parent={$pagefield->parent_id}" : "";
        $pf_template_id = $pagefield->template_id ? ", template={$pagefield->template_id}" : "";

        $newArray = array();
        foreach($array as $value) {
            $newArray[] = $this->pages->get("name={$value}{$pf_parent_id}{$pf_template_id}")->id;
        }

        return $newArray;
    }


    /**
     * Returns field with embedded links converted to format for compatibility with PageLinkAbstractor module (for import process)
     *
     */
    public function abstractedLinkEncoder($value) {

        if(!$this->modules->get("PageLinkAbstractor")) return $value;

        $rootUrl = $this->config->urls->root;

        // check if the value has links by looking for equals sign and quote
        if(strpos($value, '="') || strpos($value, "='") || strpos($value, "=$rootUrl")) {

            // replace root url with tag, should work with images or tags
            $value = preg_replace('{(=["\']?)' . preg_quote($rootUrl) . '}', '$1{~root_url}', $value);

            // replace page URLs
            if(preg_match_all('|\{~root_url\}([-_./a-zA-Z0-9]+)|', $value, $matches)) {
                $assetsUrl = $this->config->urls->assets;
                foreach($matches[1] as $key => $url) {
                    if(strpos($url, $assetsUrl) !== false) continue;
                    $p = $this->pages->get("/$url");
                    if($p->id) $value = str_replace($matches[0][$key], '{~page_' . $p->id . '_url}', $value);
                }
            }

        }

        return $value;

    }

    /**
     * Returns RTE field with links to embedded images renamed to replace page ID with the path of the page so it can be converted on import at destination PW install
     *
     */
    public function nameImagePathId($html, $pagepath){
        if (strpos($html,'<img') === false) return $html; //return early if no images are embedded in html
        $dom = new DOMDocument();
        $dom->loadHTML($html);
        foreach ($dom->getElementsByTagName('img') as $img) {
            $img->setAttribute( 'src', $pagepath . pathinfo($img->getAttribute('src'), PATHINFO_BASENAME));
        }
        return $dom->saveHTML();
    }


    /**
     * Returns RTE field with links to embedded images renamed to replace the path of the page with the assets/files/xxx so it will work at destination PW install
     *
     */
    public function idImagePath($html, $wp){
        if (strpos($html,'<img') === false) return $html; //return early if no images are embedded in html
        $dom = new DOMDocument();
        $dom->loadHTML($html);
        foreach($dom->getElementsByTagName('img') as $img){
            $img->setAttribute('src', $wp->filesManager()->url() . pathinfo($img->getAttribute('src'), PATHINFO_BASENAME));
        }
        return $dom->saveHTML();
    }


    /**
     * Returns field with absatracted links converted back to normal urls (for export process)
     *
     */
    public function abstractedLinkDecoder($value) {

        if(!$this->modules->get("PageLinkAbstractor")) return $value;

        $changes = 0;
        $errors = array();

        if(strpos($value, '{~page_') !== false) {
            if(preg_match_all('/\{~page_(\d+)_url\}/', $value, $matches)) {
                foreach($matches[1] as $key => $id) {
                    $p = $this->pages->get((int) $id);
                    if(!$p->id) {
                        // notify editor that they have an invalid link
                        $errors[] = "Links to page ID $id that does not exist";
                        continue;
                    }
                    if($p->isTrash()) {
                        // notify editor tthat they are linking to a page in the trash
                        $errors[] = "Links to page ID $id that is in the trash";
                        continue;
                    }
                    $value = str_replace($matches[0][$key], $p->url, $value);
                    $changes++;
                }
            }
        }

        if(strpos($value, '{~root_url}') !== false) {
            $value = str_replace('{~root_url}', $this->config->urls->root, $value);
            $changes++;
        }

        if(count($errors)) {
            $wp = $arguments[0];
            if($wp->editable()) {
                foreach($errors as $error) $this->error("Page {$wp->path} $error");
            }
        }
        else{
            return $value;
        }

    }



    /**
     * Create zip archive of attached files for migration
     *
     */
    function create_zip($files = array(), $destination = '', $filetype, $overwrite = false) {
        //if the zip file already exists and overwrite is false, return false
        //if(file_exists($destination) && !$overwrite) return false;
        $valid_files = array();
        if(is_array($files)) {
            foreach($files as $file) {
                if(file_exists($file['currentpath'])) $valid_files[] = $file;
            }
        }
        if(count($valid_files)) {
            //create the archive
            $zip = new ZipArchive();
            if($zip->open($destination, $overwrite ? ZIPARCHIVE::OVERWRITE : ZIPARCHIVE::CREATE) !== true) return false;
            //add the files
            if($filetype == 'files'){
                foreach($valid_files as $path => $file) {
                    $zip->addFile($file['currentpath'],$file['newpath']);
                }
            }
            elseif($filetype == 'json'){
                foreach($valid_files as $file) {
                    $zip->addFile($file, pathinfo($file, PATHINFO_BASENAME));
                }
            }
            //echo 'The zip archive contains ',$zip->numFiles,' files with a status of ',$zip->status;
            $zip->close();

            //check to make sure the file exists
            return file_exists($destination);
        }
        else{
            return false;
        }
    }


    /**
     * Function to recursively delete an entire folder
     *
     */
    public function recursiveDelete($str){
        if(is_file($str)){
            return @unlink($str);
        }
        elseif(is_dir($str)){
            $scan = glob(rtrim($str,'/').'/*');
            foreach($scan as $index=>$path){
                $this->recursiveDelete($path);
            }
            return @rmdir($str);
        }
    }



    /**
     * Install the module and create the page where it lives
     *
     */
    public function ___install() {

        if(ProcessWire::versionMajor == 2 && ProcessWire::versionMinor < 4) {
            throw new WireException("This module requires ProcessWire 2.4 or newer");
        }

        $wp = $this->getInstalledPage();
        $this->message("Installed to {$wp->path}");
        if($wp->parent->name == 'setup') $this->message("Click to your 'Setup' page to start using the Page Tree Migrator");
    }

    /**
     * Return the page that this Process is installed on
     *
     */
    protected function getInstalledPage() {

        $admin = $this->pages->get($this->config->adminRootPageID);
        $parent = $admin->child("name=setup");
        if(!$parent->id) $parent = $admin;
        $wp = $parent->child("name=" . self::adminPageName);

        if(!$wp->id) {
            $wp = new Page();
            $wp->parent = $parent;
            $wp->template = $this->templates->get('admin');
            $wp->name = self::adminPageName;
            $wp->title = "Page Tree Migrator";
            $wp->process = $this;
            $wp->sort = $parent->numChildren;
            $wp->save();
        }

        return $wp;
    }

    /**
     * Uninstall the module
     *
     */
    public function ___uninstall() {
        $wp = $this->getInstalledPage();
        if($wp->id) {
            $this->message("Removed {$wp->path}");
            $this->pages->delete($wp);
        }
    }

}
