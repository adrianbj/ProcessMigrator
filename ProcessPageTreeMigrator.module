<?php

/**
 * ProcessWire Page Tree Migrator
 * by Adrian Jones
 *
 * Allows automated migration and sharing of page trees along with their templates and fields.
 *
 * ProcessWire 2.x
 * Copyright (C) 2011 by Ryan Cramer
 * Licensed under GNU/GPL v2, see LICENSE.TXT
 *
 * http://www.processwire.com
 * http://www.ryancramer.com
 *
 */

class ProcessPageTreeMigrator extends Process implements Module {

    /**
     * getModuleInfo is a module required by all modules to tell ProcessWire about them
     *
     * @return array
     *
     */
    public static function getModuleInfo() {
        return array(
            'title' => 'Page Tree Migrator',
            'version' => 9,
            'summary' => 'Automated migrate page trees (including their templates and fields) from one PW installation to another',
            'singular' => true,
            'autoload' => false,
            );
    }

    /**
     * Name used for the page created in the admin
     *
     */
    const adminPageName = 'page-tree-migrator';


    /**
     * Filename with path to json file
     *
     */
    protected $jsonFilename = '';

    /**
     * Instance of Template, used for imported pages
     *
     */
    protected $template = null;

    /**
     * Instance of Page, representing the parent Page for imported pages
     *
     */
    protected $parent = null;

    /**
     * Initialize the module
     *
     */
    public function init() {
        parent::init();
        ini_set('auto_detect_line_endings', true);
    }

    /**
     * Executed when root url for module is accessed
     *
     */
    public function ___execute() {

        $form = $this->buildForm1();
        if($this->input->post->submit) {
            if($this->processForm1($form) || $this->processExportForm2($form) || $this->processImportForm2($form)) $this->session->redirect('./'.$this->input->post->type.'/');
        }
        return $form->render();
    }

    /**
     * Executed when ./export/ url for module is accessed
     *
     */
    public function ___executeExport() {

        $form = $this->buildExportForm2();
        if($this->input->post->submit) {
            return $this->processExportForm2($form);
        } else {
            $form = $this->buildExportForm2();
            return $form->render();
        }
    }


    /**
     * Executed when ./import/ url for module is accessed
     *
     */
    public function ___executeImport() {

        $form = $this->buildImportForm2();
        if($this->input->post->submit) {
            return $this->processImportForm2($form);
        } else {
            $form = $this->buildImportForm2();
            return $form->render();
        }

    }




/**
     * Build the "Step 1" form
     *
     */
    protected function buildForm1() {

        $form = $this->modules->get("InputfieldForm");
        $form->method = 'post';
        $form->description = "Step 1: Export or Import";

        $f = $this->modules->get("InputfieldSelect");
        $f->name = 'type';
        $f->label = 'Export or Import';
        $f->required = true;
        $f->addOption('');
        $f->addOption('export', 'Export');
        $f->addOption('import', 'Import');
        if($this->session->type) $f->attr('value', $this->session->type);
        $form->add($f);

        $this->addSubmit($form, 'Continue to Step 2');

        return $form;
    }



    /**
     * Process the "Step 1" form and populate session variables with the results
     *
     */
    protected function processForm1(InputfieldForm $form) {

        $form->processInput($this->input->post);
        if(count($form->getErrors())) return false;

        $this->session->type = (int) $form->get('type')->value;

        $type = $form->get('type')->value;

        if(!$type) {
            $this->error("Missing required Export/Import action type");
            return false;
        }

        $this->session->type = $type;
        return true;
    }




    /**
     * Build the "Export Step 2" form
     *
     */
    protected function buildExportForm2() {

        $form = $this->modules->get("InputfieldForm");
        $form->method = 'post';
        $form->description = "Step 2: Export Page Tree";

        $f = $this->modules->get("InputfieldPageListSelect");
        $f->name = 'treeParent';
        $f->label = 'Parent Page';
        $f->required = true;
        $f->description = "The parent of the page tree you want to export.";
        if($this->session->treeParent) $f->attr('value', $this->session->treeParent);
        $form->add($f);

        $f = $this->modules->get("InputfieldSelect");
        $f->name = 'export_components';
        $f->label = 'Components to export';
        $f->required = true;
        $f->addOption('');
        $f->addOption('everything', 'Everything, including all data pages');
        $f->addOption('fields_templates_and_structural_pages', 'Fields, Templates and Structural Pages');
        $f->addOption('fields_and_templates_only', 'Fields and Templates Only');
        if($this->session->export_components) $f->attr('value', $this->session->export_components);
        $form->add($f);

        $f = $this->modules->get("InputfieldSelect");
        $f->name = 'save_or_copy';
        $f->label = 'Output Format';
        $f->description = 'SAVE json file to your computer OR display code so you can COPY and then paste into new site.';
        $f->required = true;
        $f->addOption('');
        $f->addOption('save', 'Save');
        $f->addOption('copy', 'Copy');
        if($this->session->save_or_copy) $f->attr('value', $this->session->save_or_copy);
        $form->add($f);

        $this->addSubmit($form, 'Export');

        return $form;
    }

    /**
     * Process the "Step 2" form and populate session variables with the results
     *
     */
    protected function processExportForm2(InputfieldForm $form) {

        $form->processInput($this->input->post);
        if(count($form->getErrors())) return false;

        $this->session->treeParent = (int) $this->input->treeParent;
        $this->session->save_or_copy = $this->input->save_or_copy;
        $this->session->export_components = $this->input->export_components;

        $items = $this->pages->get($this->session->treeParent)->find("include=all");
        $parent_item = $this->pages->get($this->session->treeParent);
        $items->prepend($parent_item);


        if($this->session->save_or_copy == 'copy'){
            return '<p><textarea rows="10" style="width:95%">' . $this->pagesToJSON($items, $this->session->export_components) . '</textarea></p><p>Copy this text and import it into your new site using the paste option.</p><p><a href="../export/">Export more pages</a></p>';
        }
        else{
            header('Content-disposition: attachment; filename='.$this->pages->get($this->session->treeParent)->name.'.json');
            header('Content-type: application/json');
            echo ($this->pagesToJSON($items, $this->session->export_components));
            exit;
        }

    }

    /**
     * Build the "Import Step 2" form to import the json file
     *
     */
    protected function buildImportForm2() {


        $form = $this->modules->get("InputfieldForm");
        $form->method = 'post';
        $form->description = "Step 2: Import Page Tree";

        $f = $this->modules->get("InputfieldPageListSelect");
        $f->name = 'import_to_parent';
        $f->label = 'Parent Page';
        $f->description = "The parent that you want the imported pages added to.\r\nNB This is not required if you choose 'Fields and Templates Only' from the options below.";
        if($this->session->import_to_parent) $f->attr('value', $this->session->import_to_parent);
        $form->add($f);

        $f = $this->modules->get("InputfieldSelect");
        $f->name = 'import_components';
        $f->label = 'Components to import';
        $f->required = true;
        $f->addOption('everything', 'Everything, including all data pages');
        //$f->addOption('fields_templates_and_structural_pages', 'Fields, Templates and Structural Pages');
        $f->addOption('fields_and_templates_only', 'Fields and Templates Only');
        if($this->session->import_components) $f->attr('value', $this->session->import_components);
        $form->add($f);

        $fieldset = $this->modules->get("InputfieldFieldset");
        $fieldset->attr('id', 'json_source_options');
        $fieldset->label = "JSON Source";
        $fieldset->description = "Choose one of the following options as the source of the JSON data.\r\nNB: The structure of this JSON is critical, so it is important that it was created using the export feature of this module.";
        $form->add($fieldset);

        $f = $this->modules->get("InputfieldFile");
        $f->name = 'json_file';
        $f->label = 'JSON File Upload';
        $f->extensions = 'json';
        $f->maxFiles = 1;
        $f->descriptionRows = 0;
        $f->overwrite = true;
        $f->collapsed = Inputfield::collapsedBlank;
        $fieldset->add($f);

        $f = $this->modules->get("InputfieldTextarea");
        $f->name = 'json_data';
        $f->label = 'Paste in JSON Data';
        $f->collapsed = Inputfield::collapsedBlank;
        $fieldset->add($f);

        $f = $this->modules->get("InputfieldSelect");
        $f->name = 'json_package';
        $f->label = 'Shared JSON packages';
        //$packages = json_decode(file_get_contents('https://raw.github.com/adrianbj/ProcessWirePageLists/master/packages.json'));
        $packages = json_decode(file_get_contents('https://api.github.com/repos/adrianbj/ProcessWirePageLists/contents/'));
        if(!is_array($packages)) {
            $this->error("Github rate limit has been exceeded. Please try again shortly.");
            $f->description = __("Github rate limit has been exceeded. Please try again shortly.");
        }
        else{
            $f->addOption('');
            foreach($packages as $package){
                $package_name = pathinfo($package->html_url, PATHINFO_FILENAME);
                $package_raw_url = str_replace('//','//raw.', str_replace('blob/','',$package->html_url));
                if($package_name != 'README') $f->addOption($package_raw_url, $package_name);
            }
            if($this->session->json_package) $f->attr('value', $this->session->json_package);
            $f->description = __("Select from one of the shared JSON packages.\r\nMore details about these packages are available at the ProcessWirePageLists Github page: [https://github.com/adrianbj/ProcessWirePageLists](https://github.com/adrianbj/ProcessWirePageLists)");
        }
        $f->collapsed = Inputfield::collapsedBlank;
        $fieldset->add($f);

        $f = $this->modules->get("InputfieldURL");
        $f->name = 'json_url';
        $f->label = 'URL to JSON file';
        $f->description = "Enter a URL directly to a .json file, eg: [https://raw.github.com/adrianbj/ProcessWirePageLists/master/countries.json](https://raw.github.com/adrianbj/ProcessWirePageLists/master/countries.json)";
        $f->collapsed = Inputfield::collapsedBlank;
        $fieldset->add($f);


        $this->addSubmit($form, 'Upload and Create Content');

        return $form;
    }

    /**
     * Process the "Import Step 2" form and upload the json file
     *
     */
    protected function processImportForm2(InputfieldForm $form) {

        $form->processInput($this->input->post);
        if(count($form->getErrors())) return false;

        $this->session->import_to_parent = (int) $this->input->import_to_parent;
        $this->session->import_components = $this->input->import_components;


        if(!$this->session->import_to_parent && $this->session->import_components != 'fields_and_templates_only') {
            $this->error("Missing required parent page. This must be selected if you want to import the pages in addition to field and template creation.");
            $this->session->redirect('./'.$this->input->post->type);
        }


        $jsonFile = $form->get('json_file')->value;
        $jsonData = $form->get('json_data')->value;
        $jsonPackage = $form->get('json_package')->value;
        $jsonURL = $form->get('json_url')->value;


        if(count($jsonFile)) {
            $jsonFile = $jsonFile->first();
            $jsonFile->rename("data.json");
            $jsonFilename = $jsonFile->filename;
        }

        else{

            if(strlen($jsonData)) {
                $json = $jsonData;
            }
            else if(strlen($jsonPackage)) {
                $json = file_get_contents($jsonPackage);
            }
            else if(strlen($jsonURL)) {
                $json = file_get_contents($jsonURL);
            }

            //$jsonFilename = $this->config->paths->files . ($this->config->pagefileSecure ? $this->config->pagefileSecurePathPrefix : null) . $this->page->id . '/data.json';
            $jsonFilename = $this->page->filesManager()->path() . 'data.json';
            file_put_contents($jsonFilename, $json);

        }


        if(!$jsonFilename || !is_file($jsonFilename)) {
            $this->error("Missing required JSON Source");
            $this->session->redirect('./'.$this->input->post->type);
        }

        $fp = file_get_contents($jsonFilename);
        $data = json_decode($fp);



        //Templates - first iteration to create templates
        foreach($data->templates as $np){

            if(!$this->fieldgroups->{$np->template}) {
                $fg = new Fieldgroup();
                $fg->name = $np->template;
                $fg->add("title");
                $fg->save();
            }
            else{
                $fg = $this->fieldgroups->{$np->template};
            }

            if(!$this->templates->{$np->template}) {
                $template = new Template();
                $template->name = $np->template;
                $template->fieldgroup = $fg;
                $template->save();
            }
            else{
                $template = $this->templates->{$np->template};
            }

        }


        //Templates - second iteration to save settings.
        //Had to separate because it isn't possible to populate childTemplates / parentTemplates arrays if the template to be set isn't created yet
        foreach($data->templates as $np){

            $template = $this->templates->{$np->template};
            $fg = $this->fieldgroups->{$np->template};

            foreach($np->data as $np_field_name => $np_field_value){
                if(is_array($np_field_value)) {
                    $id = array_map(array($this, 'getTemplateIDFromName'), $np_field_value);
                    $template->$np_field_name = $id;
                }
                else{
                    $template->$np_field_name = $np_field_value;
                }
            }

            $template->fieldgroup = $fg;
            $template->save();

        }



        //Fields
        foreach($data->fields as $np){

            $template = $this->templates->{$np->template};

            if(!$this->fields->{$np->name}){
                $field = new Field();
                $field->type = $this->modules->get($np->type); // get a field type
                $field->name = $np->name;
                $field->label = $np->label;
                $field->description = $np->description;
                $field->flags = $np->flags;


                foreach($np->data as $np_field_name => $np_field_value){

                    if($this->modules->get($np->type) == "FieldtypeRepeater"){

                        $repeater_fieldgroup = "repeater_{$np->name}";

                        if(!$this->fieldgroups->$repeater_fieldgroup) {
                            $repeater_fg = new Fieldgroup();
                            $repeater_fg->name = $repeater_fieldgroup;
                        }
                        else{
                            $repeater_fg = $this->fieldgroups->$repeater_fieldgroup;
                        }

                        if(is_array($np_field_value)) {  // Think this is limited to repeaters and nothing else - need to check
                            foreach($np_field_value as $rf){
                                $repeater_fg->append($rf); //Populates fieldgroups_fields with IDs of repeater subfields
                            }
                        }
                        $repeater_fg->save();

                        if(!$this->templates->$repeater_fieldgroup) {
                            $repeater_template = new Template();
                            $repeater_template->name = $repeater_fieldgroup;
                            $repeater_template->flags = 8;
                            $repeater_template->noChildren = 1;
                            $repeater_template->noParents = 1;
                            $repeater_template->noGlobal = 1;
                            $repeater_template->slashUrls = 1;
                            $repeater_template->fieldgroup = $repeater_fg;
                            $repeater_template->save();
                        }
                        else{
                            $repeater_template = $this->templates->$repeater_fieldgroup;
                        }

                        //Need to override these values in the JSON data because they come from the source PW install and aren't relevant here when importing
                        if($np_field_name == "template_id") $np_field_value = $repeater_template->id;
                        if($np_field_name == "parent_id") {
                            $repeater_page = "for-field-{$field->id}";
                            $np_field_value = $this->pages->get("name=$repeater_page")->id;
                        }
                    }

                    if($this->modules->get($np->type) == "FieldtypePage"){
                        //Need to override these values in the JSON data because they come from the source PW install and aren't relevant here when importing
                        if($np_field_name == "template_id") $np_field_value = $this->templates->get("name=$np_field_value")->id;
                        if($np_field_name == "parent_id") $np_field_value = $this->pages->get("name=$np_field_value")->id;
                    }

                    if(is_array($np_field_value)) { // Think this is limited to repeaters and nothing else - need to check
                        $id = array_map(array($this, 'getFieldIDFromName'), $np_field_value);
                        $field->$np_field_name = $id; //Populates fields > data > repeaterFields with IDs of repeater subfields
                    }
                    else{
                        $field->$np_field_name = $np_field_value;
                    }

                }

                $field->save(); // save the field
                if($template) $template->fieldgroup->append($field); // add new field to template. If $template checks are for repeater subfields - don't want to add these to a standard template
            }
            else{
                if($template) $template->fieldgroup->append($this->fields->{$np->name}); // add existing field to template - NB: this does not change any of the attributes of a field if it already exists - this could be problematic for the import
            }

            if($template) $template->fieldgroup->save();

        }


        //Pages
        $i=0;
        $top_parent_page = '';

        if($this->session->import_components == 'everything'){

            if(isset($data->pages)){

                foreach($data->pages as $np){

                    $import_to_parent = $this->pages->get($form->get('import_to_parent')->value);
                    $parent = $this->pages->get($import_to_parent->path.$np->parent_name.'/');
                    if(!$parent->id) $parent = $this->pages->get('/');

                    //if($i==1) $top_parent_page = $parent; //Used for link to show created page tree

                    if(!$this->pages->get("name={$np->name}, template={$np->page_template}, parent=$parent")->id){ //Check to see if a page with same name, template and parent already exists before creating it
                        $page = new Page();
                        $page->parent = $parent;
                        $page->template = $this->templates->{$np->page_template};
                        $page->name = $np->name;
                        $page->sort = $np->sort;
                        if(isset($np->sortfield)) $page->sortfield = $np->sortfield;
                        $page->of;
                        $page->save();

                        if($i==0) $top_parent_page = $page; //Used for link to show created page tree

                        foreach($np->data as $np_field_name => $np_field_value){
                            if(!is_array($np_field_value)){ // not supporting fields with arrays as values yet - need to get exporter to handle this first - currently it only stores the ids in the array - need to get titles/names
                                if(is_object($np_field_value)){ // this is for multi language versions of fields, but maybe there are other things that might be objects that need to be dealt with - maybe page fields?
                                    foreach($np_field_value as $language => $field_value){
                                        $page->$np_field_name->setLanguageValue($this->languages->get($language), $this->abstractedLinkEncoder($field_value));
                                    }
                                }
                                else{
                                    $page->$np_field_name = $this->abstractedLinkEncoder($np_field_value);
                                }
                            }
                        }
                        $page->save();

                    }

                    $i++;

                }

            }

        }


        unlink($jsonFilename);

        return $this->processImportForm2Markup($i, $top_parent_page != '' ? $top_parent_page->id : false);

    }


    /**
     * Push all relevant templates, fields and pages to the pageToArray function and then JSON encode
     *
     */
    protected function pagesToJSON(PageArray $items, $export_components) {

        $a = array();
        $templates_array = array();
        $fields_array = array();
        $current_template = '';
        $i=0;
        foreach($items as $item) {

            //Pages
            if($export_components != 'fields_and_templates_only'){
                if($export_components == 'everything' || ($export_components == 'fields_templates_and_structural_pages' && count($item->siblings("children.count>0"))>0)){
                    $a['pages'][] = $this->pageToArray($item, 'pages', null, $i);
                }
            }

            //Templates
            if(!in_array($item->template->name, $templates_array)){
                $a['templates'][] = $this->pageToArray($item, 'templates', null, $i);
                $templates_array[] = $item->template->name;
            }

            //Fields
            foreach($this->templates->get($item->template->name)->fields as $field){
                if(!in_array($field->name, $fields_array) || $item->template->name != $current_template){

                    // if it's a repeater field then need to look through its subfields and add those to array if not already present
                    if($field->type=="FieldtypeRepeater"){
                        foreach($field->repeaterFields as $repeaterField){
                            //$repeater_fields[] = $repeater_subfield;
                             $repeater_subfield = $this->fields->get($repeaterField);

                            if(!in_array($repeater_subfield->name, $fields_array)){

                                $a['fields'][] = $this->pageToArray($repeater_subfield, 'fields', null, $i);
                                $fields_array[] = $repeater_subfield->name;

                            }
                        }
                    }

                    $a['fields'][] = $this->pageToArray($field, 'fields', $item->template->name, $i);
                    $fields_array[] = $field->name;

                    $current_template = $item->template->name;
                }
            }
            $i++;

        }
        return json_encode($a);
    }


    /**
     * Prepare arrays to convert to JSON
     *
     */
    protected function pageToArray($page, $type, $template_name = null, $pageNum = 0) {

        if($type == 'pages'){

            $data = array(
                'name' => $page->name,
                'parent_name' => $pageNum == 0 ? '' : $this->removeParentFromPath($page->parent->path),
                'page_template' => $page->template->name,
                'status' => $page->status,
                'sort' => $page->sort,
                'sortfield' => $page->sortfield,
                'data' => array(),
            );

            foreach($page->template->fieldgroup as $field) {
                // Exclude certain filetypes from page content export. NB We are still exporting the required fields and templates for these fields, just not the content
                // Maybe add support for these at some point? How to handle images embedded in a RTE field?
                // Repeater and Page types should be doable, but copying images and files will probably always be beyond the scope of this module
                if($field->type instanceof FieldtypeImage || $field->type instanceof FieldtypeFile || $field->type instanceof FieldtypeRepeater || $field->type instanceof FieldtypePage) continue;

                $value = $page->get($field->name);
                $final_value = $field->type->sleepValue($page, $field, $value);

                if(is_array($final_value) && $this->modules->isInstalled("LanguageSupport")) {
                    $data['data'][(string) $field] = $this->getLanguageNameFromID($this->abstractedLinkDecoder($final_value));
                }
                else {
                    $data['data'][(string) $field] = $this->abstractedLinkDecoder($final_value);
                }

            }

        }


        if($type == 'templates'){

            $data = array(
                'template' => $page->template->name,
            );

            foreach($page->template->getArray() as $field => $value) {

                $field_names[] = $value;

                if(is_array($value) && !empty($value) && $value[0] != 0) { //Last check to hopefully deal with an error when childTemplates or parentTemplates somehow ended up as [0] => 0
                    $names = array_map(array($this, 'getTemplateNameFromID'), $value);
                    $data['data'][$field] = $names;
                }
                else{
                    $data['data'][$field] = $value;
                }
            }
        }


        if($type == 'fields'){

            $data = array(

                'name' => $page->name,
                'label' => $page->label,
                'description' => $page->description,
                'template' => $template_name,
                'flags' => $page->flags,
                'type' => "{$page->type}",

            );

            foreach($page->getArray() as $field => $value) {

                if(is_array($value) && !empty($value) && $value[0] != 0) { //Last check to hopefully deal with an error when childTemplates or parentTemplates somehow ended up as [0] => 0
                    $names = array_map(array($this, 'getFieldNameFromID'), $value);
                    $data['data'][$field] = $names;
                }
                else{
                    if($field == "parent_id"){ // convert page id to name for page field selectable parent
                        $data['data'][$field] = $this->pages->get($value)->name;
                    }
                    elseif($field == "template_id"){ // convert template id to name for page field selectable template
                        $data['data'][$field] = $this->templates->get($value)->name;
                    }
                    else{
                        $data['data'][$field] = $value;
                    }
                }
            }

        }

        return $data;
    }




    /**
     * Provide the completion output markup for processImportForm2
     *
     */
    protected function processImportForm2Markup($numImported, $parent_id) {
        $out = '';
        if($parent_id){
            $out .= "<h2>Created all required templates and fields and imported $numImported pages</h2>" .
            "<p><a href='{$this->config->urls->admin}page/list/?open={$parent_id}'>View the imported page tree</a></p>";
        }
        else{
            $out .= "<h2>Created all required templates and fields</h2>";
        }

        $out .= "<p><a href='../import/'>Import more content</a></p>";

        return $out;
    }



    /**
     * Add a submit button, moved to a function so we don't have to do this several times
     *
     */
    protected function addSubmit(InputfieldForm $form, $value = 'Submit') {
        $f = $this->modules->get("InputfieldSubmit");
        $f->name = 'submit';
        $f->value = $value;
        $form->add($f);
    }


    /**
     * Remove the parent section from the URL path of a page
     *
     */
    protected function removeParentFromPath($path){
        $parts = explode('/', substr($path, 1));
        if(count($parts)>2) array_shift($parts);
        return implode('/', $parts);
    }

    /**
     * Return template name from its ID
     *
     */
    public function getTemplateNameFromID($id){
        if($this->templates->get($id)) return $this->templates->get($id)->name;
    }

    /**
     * Return field name from its ID
     *
     */
    public function getFieldNameFromID($id){
        if($this->fields->get($id)) return $this->fields->get($id)->name;
    }


    /**
     * Return template ID from its name
     *
     */
    public function getTemplateIDFromName($name){
        if($name != '' && $this->templates->get($name)) return $this->templates->get($name)->id;
    }

    /**
     * Return field ID from its name
     *
     */
    public function getFieldIDFromName($name){
        if($this->fields->get($name)) return $this->fields->get($name)->id;
    }

    /**
     * Return language name from its ID
     *
     */
    public function getLanguageNameFromID( $array )
    {

        $newArray = array();

        foreach($array as $key=>$value) {
            $language_id = preg_replace("/[^0-9]/", "", $key);
            $newArray[$language_id ? $this->languages->get($language_id)->name : 'default'] = $this->abstractedLinkDecoder($value);
        }

        return $newArray;

    }


    /**
     * Returns field with embedded links converted to format for compatibility with PageLinkAbstractor module (for import process)
     *
     */
    public function abstractedLinkEncoder($value) {

        if(!$this->modules->get("PageLinkAbstractor")) return $value;

        $rootUrl = $this->config->urls->root;

        // check if the value has links by looking for equals sign and quote
        if(strpos($value, '="') || strpos($value, "='") || strpos($value, "=$rootUrl")) {

            // replace root url with tag, should work with images or tags
            $value = preg_replace('{(=["\']?)' . preg_quote($rootUrl) . '}', '$1{~root_url}', $value);

            // replace page URLs
            if(preg_match_all('|\{~root_url\}([-_./a-zA-Z0-9]+)|', $value, $matches)) {
                $assetsUrl = $this->config->urls->assets;
                foreach($matches[1] as $key => $url) {
                    if(strpos($url, $assetsUrl) !== false) continue;
                    $p = $this->pages->get("/$url");
                    if($p->id) $value = str_replace($matches[0][$key], '{~page_' . $p->id . '_url}', $value);
                }
            }

        }

        return $value;

    }


    /**
     * Returns field with absatracted links converted back to normal urls (for export process)
     *
     */
    public function abstractedLinkDecoder($value) {

        if(!$this->modules->get("PageLinkAbstractor")) return $value;

        $changes = 0;
        $errors = array();

        if(strpos($value, '{~page_') !== false) {
            if(preg_match_all('/\{~page_(\d+)_url\}/', $value, $matches)) {
                foreach($matches[1] as $key => $id) {
                    $p = $this->pages->get((int) $id);
                    if(!$p->id) {
                        // notify editor that they have an invalid link
                        $errors[] = "Links to page ID $id that does not exist";
                        continue;
                    }
                    if($p->isTrash()) {
                        // notify editor tthat they are linking to a page in the trash
                        $errors[] = "Links to page ID $id that is in the trash";
                        continue;
                    }
                    $value = str_replace($matches[0][$key], $p->url, $value);
                    $changes++;
                }
            }
        }

        if(strpos($value, '{~root_url}') !== false) {
            $value = str_replace('{~root_url}', $this->config->urls->root, $value);
            $changes++;
        }

        if(count($errors)) {
            $page = $arguments[0];
            if($page->editable()) {
                foreach($errors as $error) $this->error("Page {$page->path} $error");
            }
        }
        else{
            return $value;
        }

    }



    /**
     * Install the module and create the page where it lives
     *
     */
    public function ___install() {

        if(ProcessWire::versionMajor == 2 && ProcessWire::versionMinor < 1) {
            throw new WireException("This module requires ProcessWire 2.1 or newer");
        }

        $page = $this->getInstalledPage();
        $this->message("Installed to {$page->path}");
        if($page->parent->name == 'setup') $this->message("Click to your 'Setup' page to start using the Page Tree Migrator");
    }

    /**
     * Return the page that this Process is installed on
     *
     */
    protected function getInstalledPage() {

        $admin = $this->pages->get($this->config->adminRootPageID);
        $parent = $admin->child("name=setup");
        if(!$parent->id) $parent = $admin;
        $page = $parent->child("name=" . self::adminPageName);

        if(!$page->id) {
            $page = new Page();
            $page->parent = $parent;
            $page->template = $this->templates->get('admin');
            $page->name = self::adminPageName;
            $page->title = "Page Tree Migrator";
            $page->process = $this;
            $page->sort = $parent->numChildren;
            $page->save();
        }

        return $page;
    }

    /**
     * Uninstall the module
     *
     */
    public function ___uninstall() {
        $page = $this->getInstalledPage();
        if($page->id) {
            $this->message("Removed {$page->path}");
            $this->pages->delete($page);
        }
    }

}
